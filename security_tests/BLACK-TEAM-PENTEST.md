# Penetration Test Report - Mr BlackKeys

**Date:** 2026-02-16
**Project:** pfm
**Scope:** pfm/ (project source code, tests, examples)
**Scope Verification:** Confirmed within allowed project boundary
**Tester:** Mr BlackKeys - Lead Penetration Tester

## Pre-Scan Checklist
- [x] Path within allowed projects
- [x] User explicitly requested scan
- [x] Scope is specific project, not root
- [x] Knowledge base consulted (UNI-xxx universal vectors applied)

---

## Executive Summary

The PFM project is a Python library defining a new file format (.pfm) for AI agent output, including a writer, reader, converter suite, cryptographic security module, streaming writer with crash recovery, and a CLI tool.

**Total findings: 19**

| Severity | Count |
|----------|-------|
| CRITICAL | 3     |
| HIGH     | 6     |
| MEDIUM   | 7     |
| LOW      | 3     |

The most severe issues are: (1) arbitrary attribute injection via `setattr` on deserialized input, (2) content injection / section spoofing via markers embedded in content, and (3) uncontrolled memory allocation enabling denial-of-service via crafted files. The cryptographic module is generally well-constructed (PBKDF2 with 600k iterations, AES-256-GCM, HMAC-SHA256 with constant-time comparison), but has several weaknesses in how encryption is composed and how integrity is enforced.

---

## Findings

---

### CRITICAL: MBK-001 - Arbitrary Attribute Injection via setattr in Parser

**ID:** MBK-001
**Severity:** CRITICAL
**CVSS 3.1:** 9.1 (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N)
**CWE:** CWE-915 (Improperly Controlled Modification of Dynamically-Determined Object Attributes)
**Location:** `pfm/reader.py:145-146`
**Also affects:** `pfm/converters.py:108-109`, `pfm/converters.py:204-206`

**Description:**
The PFM parser uses `setattr(doc, key, val)` to populate document metadata fields from untrusted input. The guard `hasattr(doc, key) and key != "custom_meta"` is insufficient because `PFMDocument` (a dataclass) inherits many attributes. An attacker can craft a malicious `.pfm` file with meta keys that overwrite internal attributes such as `format_version`, `sections`, or any dataclass field. Most critically, `sections` can be overwritten, and `format_version` can be set to arbitrary values.

The same pattern appears in `converters.py` for CSV and Markdown import paths.

**Proof of Concept:**
```
#!PFM/1.0
#@meta
id: normal-id
format_version: INJECTED_VERSION
sections: CORRUPTED
#@content
normal content
#!END
```

When parsed, `doc.format_version` will be set to `"INJECTED_VERSION"` via `setattr`. While `sections` as a string will crash downstream code expecting a list, this demonstrates arbitrary attribute control. An attacker who maps all available attributes on `PFMDocument` and its parent classes can find exploitable targets.

For CSV import (`converters.py:108-109`):
```csv
type,key,value
meta,format_version,INJECTED
meta,__class__,hacked
section,content,normal
```

**Impact:**
- An attacker can manipulate internal document state by crafting meta fields
- Can override `format_version`, `checksum` (bypassing integrity checks), or any standard field
- Potential for logic bypass, data corruption, or downstream exploitation

**Remediation:**
Replace `setattr` with an explicit allowlist assignment pattern:
```python
ALLOWED_META_FIELDS = {"id", "agent", "model", "created", "checksum", "parent", "tags", "version"}

if key in ALLOWED_META_FIELDS:
    setattr(doc, key, value)
else:
    doc.custom_meta[key] = value
```
Do NOT use `hasattr()` as the guard -- it is far too permissive.

---

### CRITICAL: MBK-002 - Content Injection / Section Spoofing via Embedded Markers

**ID:** MBK-002
**Severity:** CRITICAL
**CVSS 3.1:** 8.6 (AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N)
**CWE:** CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component - Injection)
**Location:** `pfm/reader.py:106-167` (parser), `pfm/writer.py:33-37` (writer)

**Description:**
The PFM format has no escaping mechanism for its section markers (`#@`, `#!PFM`, `#!END`). When content contains these magic strings, the reader's line-by-line parser will interpret them as actual section boundaries, EOF markers, or magic lines.

The writer does not escape or validate content. The reader does not distinguish between "real" markers and markers embedded in content. This is acknowledged in the e2e tests (`test_special_characters_in_content`) with the comment "This is a known edge case" but the assertion only checks `loaded.content is not None` rather than verifying content integrity.

**Proof of Concept:**
```python
from pfm.document import PFMDocument
from pfm.writer import PFMWriter
from pfm.reader import PFMReader

doc = PFMDocument.create(agent="attacker")
# Inject a fake section inside the content
doc.add_section("content", "legitimate data\n#@secrets\nfake_api_key=sk-12345\n#!END")
data = PFMWriter.serialize(doc)
loaded = PFMReader.parse(data)

# loaded.content will be truncated to "legitimate data"
# loaded will have a NEW section "secrets" with content "fake_api_key=sk-12345"
# The real #!END marker is consumed by the fake one
print(loaded.content)  # "legitimate data" -- truncated!
print(loaded.get_section("secrets"))  # The injected section exists
```

**Impact:**
- Content truncation: legitimate data after an injected marker is lost
- Section spoofing: attacker-controlled content can create fake sections that downstream tools trust
- Integrity bypass: checksums are computed over original content, but readers parse different content
- If a downstream system reads "signed" sections from a PFM file, an attacker can inject arbitrary sections

**Remediation:**
1. **Option A (Preferred):** Use the index for content boundaries. The writer already computes byte offsets and lengths. The full-parse reader (`PFMReader.parse`) should use these offsets rather than scanning for markers within content regions.
2. **Option B:** Implement escaping. Any line starting with `#!` or `#@` in content should be escaped (e.g., `\#!` or `##!`) by the writer and unescaped by the reader.
3. **Option C:** Use length-prefixed content sections instead of marker-delimited.

---

### CRITICAL: MBK-003 - Uncontrolled Memory Allocation via Crafted File (DoS)

**ID:** MBK-003
**Severity:** CRITICAL
**CVSS 3.1:** 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)
**CWE:** CWE-400 (Uncontrolled Resource Consumption)
**Location:** `pfm/reader.py:88-91` (`read` method), `pfm/reader.py:180-183` (`open` method)

**Description:**
Both `PFMReader.read()` and `PFMReader.open()` load the entire file into memory with no size limit. An attacker can supply a multi-gigabyte file (or a file with an extremely long single line) to exhaust memory and crash the application.

Additionally, the parser at `reader.py:97` calls `data.decode("utf-8")` on the entire blob, then `text.split("\n")` which creates a second copy. A 2GB file will require approximately 6GB+ of memory (raw bytes + decoded string + split list).

The index parser at `reader.py:244-245` accepts arbitrary integer values for offset and length from the index without bounds checking. A crafted index with `offset=0 length=999999999999` could cause allocation of a massive slice.

**Proof of Concept:**
```python
# Craft a PFM file header followed by 4GB of content
header = b"#!PFM/1.0\n#@meta\nid: x\n#@index\ncontent 30 4294967296\n#@content\n"
# The reader will attempt to load the entire file
# Even the index entry alone (offset=30, length=4GB) will cause issues
```

**Impact:**
- Denial of service via memory exhaustion
- Application crash (OOM kill)
- In shared hosting environments, can affect other services

**Remediation:**
1. Add a configurable `max_file_size` parameter (default: e.g., 100MB) to `PFMReader.read()` and `PFMReader.open()`
2. Validate index entries: `offset + length` must not exceed the actual file size
3. Consider streaming parsing that does not require loading the entire file into memory
4. Add bounds check in `get_section`: `if offset + length > len(self._raw): raise ValueError`

---

### HIGH: MBK-004 - No Authenticated Encryption Binding Between Header and Ciphertext

**ID:** MBK-004
**Severity:** HIGH
**CVSS 3.1:** 7.4 (AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:H/A:N)
**CWE:** CWE-347 (Improper Verification of Cryptographic Signature)
**Location:** `pfm/security.py:161-169` (`encrypt_document`), `pfm/security.py:172-184` (`decrypt_document`)

**Description:**
The `encrypt_document` function prepends a plaintext header (`#!PFM-ENC/1.0\n`) to the encrypted payload. However, this header is NOT included in the AES-GCM authenticated data (the `None` parameter in `aesgcm.encrypt(nonce, data, None)`). An attacker can modify the plaintext header (e.g., change the version number, add metadata) without detection.

More critically, `decrypt_document` at line 181 uses `data.index(b"\n") + 1` to find the header boundary. An attacker could prepend additional plaintext lines before the encrypted payload, and the parser would skip to the first newline, potentially stripping legitimate encrypted data or causing the wrong bytes to be treated as ciphertext.

**Proof of Concept:**
```python
from pfm.security import encrypt_document, decrypt_document
from pfm.document import PFMDocument

doc = PFMDocument.create(agent="test")
doc.add_section("content", "secret data")
encrypted = encrypt_document(doc, "password")

# Modify the plaintext header without detection
tampered = encrypted.replace(b"#!PFM-ENC/1.0\n", b"#!PFM-ENC/2.0-TAMPERED\n")
# This still decrypts successfully because GCM doesn't cover the header
decrypted = decrypt_document(tampered, "password")
# No error -- the tampered header was accepted
```

**Impact:**
- Header manipulation without detection
- Version downgrade attacks
- Potential for confusion attacks where the header claims one thing but the payload is another
- If future versions add header metadata (e.g., key ID, algorithm specifier), these can be swapped

**Remediation:**
Use AES-GCM's associated data (AAD) parameter to bind the header to the ciphertext:
```python
# In encrypt_document:
header = b"#!PFM-ENC/1.0\n"
ciphertext = aesgcm.encrypt(nonce, data, header)  # header as AAD

# In decrypt_document:
header = data[:header_end]
plaintext = aesgcm.decrypt(nonce, ciphertext, header)  # verify header as AAD
```

---

### HIGH: MBK-005 - Path Traversal via CLI --file and --output Parameters

**ID:** MBK-005
**Severity:** HIGH
**CVSS 3.1:** 7.1 (AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N)
**CWE:** CWE-22 (Improper Limitation of a Pathname to a Restricted Directory - Path Traversal)
**Location:** `pfm/cli.py:33` (`cmd_create`), `pfm/cli.py:46` (`cmd_create`), `pfm/cli.py:123` (`cmd_convert`), `pfm/cli.py:134` (`cmd_convert`)

**Description:**
The CLI accepts file paths from user arguments without any sanitization or validation. The `--file` parameter reads arbitrary files, the `--output` parameter writes to arbitrary paths, and the `convert` command's `input` and `--output` parameters do the same.

While CLI tools traditionally trust their users, if PFM is used as part of a larger system where path arguments come from untrusted sources (e.g., a web application wrapping the CLI, or CI/CD pipelines), this becomes a path traversal vulnerability.

**Proof of Concept:**
```bash
# Read arbitrary file and embed in PFM
pfm create --file /etc/passwd -o output.pfm

# Write to arbitrary location
pfm create -c "malicious" -o /tmp/../etc/cron.d/evil

# Convert and overwrite arbitrary file
pfm convert to json input.pfm -o /important/config.json
```

**Impact:**
- Arbitrary file read (data exfiltration into PFM format)
- Arbitrary file write (overwrite system or application files)
- If CLI is wrapped by a web service, full file system access

**Remediation:**
1. Add path validation to reject `..` components and absolute paths when appropriate
2. Implement a `--root-dir` option that constrains all file operations
3. Resolve paths with `Path.resolve()` and verify they stay within expected boundaries
4. For library use, document that paths must be sanitized by the caller

---

### HIGH: MBK-006 - Checksum Bypass via Missing Checksum Treated as Valid

**ID:** MBK-006
**Severity:** HIGH
**CVSS 3.1:** 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N)
**CWE:** CWE-354 (Improper Validation of Integrity Check Value)
**Location:** `pfm/reader.py:297-302` (`validate_checksum`), `pfm/security.py:196-203` (`verify_integrity`)

**Description:**
Both `PFMReaderHandle.validate_checksum()` and `security.verify_integrity()` return `True` when no checksum is present:

```python
# reader.py:300-301
if not expected:
    return True  # No checksum to validate

# security.py:201-202
if not doc.checksum:
    return True  # No checksum stored
```

An attacker can strip the checksum from a PFM file's meta section and modify content at will. The file will still pass all integrity checks because "no checksum" is treated as "valid."

**Proof of Concept:**
```
#!PFM/1.0
#@meta
id: some-uuid
agent: legitimate-agent
#@index
content 80 20
#@content
TAMPERED CONTENT HERE
#!END
```

This file has no `checksum` field. Both `validate_checksum()` and `verify_integrity()` return `True`. An attacker who intercepts a PFM file can remove the checksum line and modify any content.

**Impact:**
- Complete bypass of integrity verification
- Silent content tampering
- Applications that rely on `validate_checksum()` or `verify_integrity()` for trust decisions are deceived

**Remediation:**
1. Return `False` (or raise an exception) when no checksum is present, rather than assuming validity
2. At minimum, provide a `require_checksum=True` parameter
3. Document clearly that unsigned/unhashed files should not be trusted:
```python
def validate_checksum(self, require: bool = True) -> bool:
    expected = self.meta.get("checksum", "")
    if not expected:
        return not require  # Fail if checksum is required but missing
    # ... rest of validation
```

---

### HIGH: MBK-007 - Signature Stripping Attack on HMAC Verification

**ID:** MBK-007
**Severity:** HIGH
**CVSS 3.1:** 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N)
**CWE:** CWE-347 (Improper Verification of Cryptographic Signature)
**Location:** `pfm/security.py:47-70` (`verify` function)

**Description:**
The `verify()` function returns `False` when no signature is found. However, the calling code and spells module (`prior_incantato`) only check `result["signed"]` as an informational field -- they do not enforce that a signature MUST be present.

More critically, there is no mechanism to indicate that a document MUST be signed. An attacker can intercept a signed PFM file, strip the `signature` and `sig_algo` custom_meta fields, modify the content, and the document will appear as simply "unsigned" rather than "tampered." There is no way to distinguish between "was never signed" and "had its signature removed."

**Proof of Concept:**
```python
from pfm.document import PFMDocument
from pfm.security import sign, verify

doc = PFMDocument.create(agent="trusted")
doc.add_section("content", "original content")
sign(doc, "secret-key")

# Attacker strips signature
del doc.custom_meta["signature"]
del doc.custom_meta["sig_algo"]

# Modify content
doc.sections[0].content = "TAMPERED CONTENT"

# verify() returns False, but caller has no way to know
# a signature was EXPECTED
result = verify(doc, "secret-key")  # Returns False
# But there's no enforcement mechanism
```

**Impact:**
- Signed documents can be silently converted to unsigned documents
- No enforcement of signature requirements
- Applications cannot distinguish between "never signed" and "signature stripped"

**Remediation:**
1. Add a `signed_by` or `requires_signature` meta field that persists even if the signature is removed
2. Provide a `verify(doc, secret, require=True)` mode that raises an exception if no signature is found
3. Include the `sig_algo` field in the standard (non-custom) meta so it survives signature stripping

---

### HIGH: MBK-008 - Race Condition in Stream Writer Crash Recovery

**ID:** MBK-008
**Severity:** HIGH
**CVSS 3.1:** 6.8 (AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H)
**CWE:** CWE-367 (Time-of-Check Time-of-Use - TOCTOU)
**Location:** `pfm/stream.py:169-238` (`_recover` function)

**Description:**
The `_recover()` function reads the file, processes it, then opens the same file in `r+b` mode and truncates it. Between the read and the truncation, another process (or a concurrent stream writer) could modify the file. The function does not use file locking.

Additionally, the recovery function at line 234 opens the file with `open(path, "r+b")` (no explicit close on the original handle from `path.read_bytes()`), seeks to `truncate_at`, and truncates. If the file grew between the read and the truncate, data will be silently lost.

The `text.index(line)` call at line 226 finds the FIRST occurrence of the matching line, which may not be the correct one if the same marker appears multiple times (e.g., in content due to MBK-002).

**Proof of Concept:**
```python
# Process 1: Normal streaming write
with PFMStreamWriter("shared.pfm", agent="writer1") as w:
    w.write_section("content", "data from writer 1")
    # Crash simulated here -- no close()

# Process 2: Concurrent recovery while Process 1 is still writing
# Between _recover reading the file and truncating it,
# Process 1 writes more data, which is then lost
with PFMStreamWriter("shared.pfm", append=True) as w:
    w.write_section("more", "this may corrupt the file")
```

**Impact:**
- Data loss during crash recovery
- File corruption from concurrent access
- Silent truncation of valid data

**Remediation:**
1. Use file locking (`fcntl.flock` on Unix, `msvcrt.locking` on Windows) during recovery
2. Read and process the file atomically -- or at minimum, check file hasn't changed after processing
3. Fix `text.index(line)` to search from the correct position to avoid false matches
4. Add a file modification timestamp check between read and truncate

---

### HIGH: MBK-009 - Integer Parsing Without Bounds Validation in Index

**ID:** MBK-009
**Severity:** HIGH
**CVSS 3.1:** 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H)
**CWE:** CWE-190 (Integer Overflow or Wraparound) / CWE-125 (Out-of-bounds Read)
**Location:** `pfm/reader.py:243-245` (`_parse_header`), `pfm/reader.py:274-280` (`get_section`)

**Description:**
Index entries are parsed with `int(offset)` and `int(length)` without any bounds validation. The `get_section` method then uses these values to slice into `self._raw`:

```python
return self._raw[offset:offset + length].decode("utf-8")
```

An attacker can craft an index with:
- Negative values (Python allows `int("-1")`, and negative slicing reads from the end)
- Values exceeding the file size (reads past intended boundaries)
- Values pointing into the meta/index sections (reads internal metadata)
- Extremely large length values causing memory allocation issues

**Proof of Concept:**
```
#!PFM/1.0
#@meta
id: test
secret_password: hunter2
#@index
content 15 22
#@content
public data only
#!END
```

A crafted index entry `content 15 22` can be set to point at the meta section bytes, leaking metadata that should not be accessible as content. Or with negative offsets, reading from unexpected positions.

**Impact:**
- Out-of-bounds read of file contents
- Leakage of metadata or other sections' content
- Memory exhaustion with large length values

**Remediation:**
```python
def get_section(self, name: str) -> str | None:
    entry = self.index.get(name)
    if entry is None:
        return None
    offset, length = entry
    if offset < 0 or length < 0 or offset + length > len(self._raw):
        raise ValueError(f"Invalid index entry for '{name}': offset={offset}, length={length}")
    return self._raw[offset:offset + length].decode("utf-8")
```

---

### MEDIUM: MBK-010 - Checksum Computed Over Sections Only, Excludes Metadata

**ID:** MBK-010
**Severity:** MEDIUM
**CVSS 3.1:** 5.3 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)
**CWE:** CWE-354 (Improper Validation of Integrity Check Value)
**Location:** `pfm/document.py:92-97` (`compute_checksum`), `pfm/reader.py:297-313` (`validate_checksum`)

**Description:**
The checksum is computed over section contents only. Metadata fields (agent, model, id, created, tags, custom_meta) are NOT included in the checksum. An attacker can modify any metadata field without invalidating the checksum.

This means an attacker can:
- Change the `agent` field to impersonate a different agent
- Modify `created` timestamps
- Alter `tags` to change classification
- Modify `model` to misrepresent which model generated the output

**Proof of Concept:**
```python
doc = PFMDocument.create(agent="trusted-agent", model="claude-opus-4-6")
doc.add_section("content", "analysis results")
data = PFMWriter.serialize(doc)

# Modify the agent field in the raw bytes
tampered = data.replace(b"agent: trusted-agent", b"agent: attacker-bot")

# Parse and validate
loaded = PFMReader.parse(tampered)
# Checksum still passes because it only covers section content
assert loaded.compute_checksum() == loaded.checksum  # True!
assert loaded.agent == "attacker-bot"  # Metadata tampered!
```

**Impact:**
- Metadata forgery while preserving "valid" checksums
- Impersonation of different agents/models
- Misleading provenance information

**Remediation:**
Include metadata in the checksum computation:
```python
def compute_checksum(self) -> str:
    h = hashlib.sha256()
    # Include metadata
    for key in sorted(self.get_meta_dict().keys()):
        if key != "checksum":  # Exclude checksum itself
            h.update(f"{key}={self.get_meta_dict()[key]}".encode("utf-8"))
    # Include sections
    for section in self.sections:
        h.update(section.content.encode("utf-8"))
    return h.hexdigest()
```

---

### MEDIUM: MBK-011 - Stream Writer Exposes Unfinished File Without Index

**ID:** MBK-011
**Severity:** MEDIUM
**CVSS 3.1:** 5.9 (AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N)
**CWE:** CWE-459 (Incomplete Cleanup)
**Location:** `pfm/stream.py:83-101` (`__init__` and `_write_header`)

**Description:**
During streaming writes, the file on disk is a valid-looking PFM file (it starts with the magic header) but has no index and no EOF marker until `close()` is called. If the file is read by another process before the writer finishes, the reader will attempt to parse it.

The `PFMReaderHandle._parse_header()` method will find the magic line and meta section but no index. For stream files, it tries `_parse_trailing_index()` which scans from the end -- but there is no trailing index yet. The reader will return a handle with an empty index, making all `get_section()` calls return `None`.

Worse, `PFMReader.parse()` (full parse) will still parse sections by scanning for markers, potentially returning partial data.

**Impact:**
- Consumers reading the file during streaming get incomplete/empty data without error
- No indication that the file is still being written
- Potential for downstream systems to act on incomplete data

**Remediation:**
1. Write a lock file or use filesystem advisory locks during streaming
2. Use a `.pfm.tmp` extension during writing, rename to `.pfm` on close
3. Add a `STREAMING` meta field that is removed on close, so readers can detect in-progress files
4. Document that stream files should not be read until closed

---

### MEDIUM: MBK-012 - Signing Message Construction Allows Ambiguity

**ID:** MBK-012
**Severity:** MEDIUM
**CVSS 3.1:** 5.4 (AV:N/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N)
**CWE:** CWE-345 (Insufficient Verification of Data Authenticity)
**Location:** `pfm/security.py:73-87` (`_build_signing_message`)

**Description:**
The signing message is constructed by joining key-value pairs and section contents with `\x00` as a separator. However, the individual parts are not length-prefixed, creating potential for ambiguity.

Consider:
- Meta: `agent=test` + Section: `[content]` + Content: `hello`
- Meta: `agent=test\x00[content]\x00hello` (same bytes if \x00 appears in values)

If any meta value or section content contains `\x00` (null bytes), the delimiter is ambiguous. While null bytes are uncommon in typical text, the format specification allows arbitrary UTF-8 content, and null bytes are valid in Python strings.

Additionally, `doc.get_meta_dict()` is called twice (lines 78 and 79), which is inefficient and could theoretically produce different results if the document is mutated concurrently.

**Impact:**
- Potential signature collision between different documents (theoretical)
- If content contains null bytes, two different documents could produce the same signing message

**Remediation:**
Use length-prefixed encoding for unambiguous message construction:
```python
def _build_signing_message(doc: PFMDocument) -> bytes:
    parts = []
    meta = doc.get_meta_dict()
    for key in sorted(meta.keys()):
        val = meta[key]
        encoded_part = f"{key}={val}".encode("utf-8")
        parts.append(len(encoded_part).to_bytes(4, 'big') + encoded_part)
    for section in doc.sections:
        name_bytes = f"[{section.name}]".encode("utf-8")
        content_bytes = section.content.encode("utf-8")
        parts.append(len(name_bytes).to_bytes(4, 'big') + name_bytes)
        parts.append(len(content_bytes).to_bytes(4, 'big') + content_bytes)
    return b"".join(parts)
```

---

### MEDIUM: MBK-013 - Verify Function Mutates Document State (Non-Atomic)

**ID:** MBK-013
**Severity:** MEDIUM
**CVSS 3.1:** 4.8 (AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:L)
**CWE:** CWE-362 (Concurrent Execution Using Shared Resource with Improper Synchronization)
**Location:** `pfm/security.py:52-70` (`verify` function)

**Description:**
The `verify()` function temporarily removes `signature` and `sig_algo` from `doc.custom_meta` to recompute the expected signature, then restores them. This mutation is not atomic.

If `verify()` is called concurrently from multiple threads, or if an exception occurs between the `pop` and restore operations (e.g., an exception in `_build_signing_message`), the document will be left in an inconsistent state with its signature fields missing.

**Proof of Concept:**
```python
import threading
from pfm.security import verify

doc = PFMDocument.create(agent="test")
doc.add_section("content", "data")
sign(doc, "key")

# Concurrent verification can cause race condition
def verify_thread():
    for _ in range(1000):
        verify(doc, "key")

threads = [threading.Thread(target=verify_thread) for _ in range(10)]
for t in threads: t.start()
for t in threads: t.join()
# doc.custom_meta may be in inconsistent state
```

**Impact:**
- Thread-safety violation
- Document corruption in concurrent scenarios
- If `_build_signing_message` raises, signature fields are permanently lost

**Remediation:**
Copy the meta dict instead of mutating the original:
```python
def verify(doc, secret):
    stored_sig = doc.custom_meta.get("signature", "")
    if not stored_sig:
        return False
    if isinstance(secret, str):
        secret = secret.encode("utf-8")

    # Build message WITHOUT mutating the document
    temp_meta = {k: v for k, v in doc.get_meta_dict().items()
                 if k not in ("signature", "sig_algo")}
    # ... use temp_meta for signing message construction
```

---

### MEDIUM: MBK-014 - Unconstrained Section Name Length and Count

**ID:** MBK-014
**Severity:** MEDIUM
**CVSS 3.1:** 5.3 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L)
**CWE:** CWE-770 (Allocation of Resources Without Limits or Throttling)
**Location:** `pfm/reader.py:121-137` (section parsing), `pfm/document.py:75-79` (`add_section`)

**Description:**
There is no limit on:
1. The number of sections in a PFM document
2. The length of section names
3. The number of meta fields

An attacker can craft a file with millions of tiny sections or sections with extremely long names to cause excessive memory allocation and CPU consumption during parsing.

**Proof of Concept:**
```python
# Generate a file with 1 million sections
lines = ["#!PFM/1.0", "#@meta", "id: x"]
for i in range(1_000_000):
    lines.append(f"#@section_{i}")
    lines.append("x")
lines.append("#!END")
malicious = "\n".join(lines).encode("utf-8")
# PFMReader.parse(malicious) will create 1M PFMSection objects
```

**Impact:**
- CPU exhaustion during parsing
- Memory exhaustion from excessive object creation
- Denial of service

**Remediation:**
1. Add configurable limits: `max_sections`, `max_section_name_length`, `max_meta_fields`
2. Default to reasonable limits (e.g., 1000 sections, 256-char names, 100 meta fields)
3. Raise `ValueError` when limits are exceeded

---

### MEDIUM: MBK-015 - Writer Does Not Validate Section Names

**ID:** MBK-015
**Severity:** MEDIUM
**CVSS 3.1:** 5.3 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L)
**CWE:** CWE-20 (Improper Input Validation)
**Location:** `pfm/document.py:75-79` (`add_section`), `pfm/writer.py:33` (serialization)

**Description:**
Section names are not validated. An attacker (or buggy code) can create sections with names containing newlines, spaces, or PFM markers:

- `add_section("content\n#@evil", "payload")` -- newline in name breaks parsing
- `add_section("name with spaces", "data")` -- breaks the index format (`name offset length` uses space-delimited parsing)
- `add_section("meta", "data")` -- section named "meta" would confuse the reader
- `add_section("", "data")` -- empty section name

The index format uses space-separated `name offset length`, so a section name containing spaces will produce unparseable index entries.

**Proof of Concept:**
```python
doc = PFMDocument.create()
doc.add_section("name with spaces", "content")
data = PFMWriter.serialize(doc)
# Index line: "name with spaces 123 7\n"
# Parser splits on spaces and expects exactly 3 parts -- gets 5 parts
# Index entry is silently dropped
```

**Impact:**
- Broken index entries that silently fail
- Potential for parser confusion
- Section names can collide with reserved names (meta, index)

**Remediation:**
Validate section names in `add_section`:
```python
import re
VALID_SECTION_NAME = re.compile(r'^[a-zA-Z][a-zA-Z0-9_-]{0,63}$')
RESERVED_NAMES = {"meta", "index", "index:trailing"}

def add_section(self, name: str, content: str) -> PFMSection:
    if not VALID_SECTION_NAME.match(name):
        raise ValueError(f"Invalid section name: {name!r}")
    if name in RESERVED_NAMES:
        raise ValueError(f"Reserved section name: {name!r}")
    section = PFMSection(name=name, content=content)
    self.sections.append(section)
    return section
```

---

### MEDIUM: MBK-016 - Encrypted File Header Parsing Vulnerable to Data Truncation

**ID:** MBK-016
**Severity:** MEDIUM
**CVSS 3.1:** 5.3 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L)
**CWE:** CWE-20 (Improper Input Validation)
**Location:** `pfm/security.py:179-182` (`decrypt_document`)

**Description:**
The `decrypt_document` function uses `data.index(b"\n") + 1` to find the end of the header. If the input data contains no newline (e.g., truncated or corrupted), this raises a `ValueError` with no meaningful error message. If the data after the newline is less than 28 bytes (16 salt + 12 nonce), the slice operations will silently produce truncated values, leading to cryptographic errors with confusing error messages.

No validation is performed on:
- Minimum data length
- Header format correctness
- That the ciphertext portion is non-empty

**Proof of Concept:**
```python
from pfm.security import decrypt_document

# Truncated data with no newline
decrypt_document(b"#!PFM-ENC/1.0", "password")
# Raises: ValueError: substring not found

# Data too short after header
decrypt_document(b"#!PFM-ENC/1.0\nshort", "password")
# Raises cryptic error from AESGCM with 5-byte "ciphertext"
```

**Impact:**
- Poor error messages obscure the actual problem
- No graceful handling of corrupted encrypted files
- Potential for unexpected exceptions propagating to callers

**Remediation:**
```python
def decrypt_document(data: bytes, password: str) -> "PFMDocument":
    if not data.startswith(b"#!PFM-ENC/"):
        raise ValueError("Data is not an encrypted PFM file")
    if b"\n" not in data:
        raise ValueError("Malformed encrypted PFM file: missing header terminator")
    header_end = data.index(b"\n") + 1
    encrypted = data[header_end:]
    if len(encrypted) < 28:  # 16 (salt) + 12 (nonce) = minimum
        raise ValueError(f"Encrypted payload too short: {len(encrypted)} bytes")
    plaintext = decrypt_bytes(encrypted, password)
    return PFMReader.parse(plaintext)
```

---

### LOW: MBK-017 - No Constant-Time Comparison for Checksum Validation

**ID:** MBK-017
**Severity:** LOW
**CVSS 3.1:** 3.7 (AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N)
**CWE:** CWE-208 (Observable Timing Discrepancy)
**Location:** `pfm/reader.py:313` (`validate_checksum`), `pfm/security.py:203` (`verify_integrity`)

**Description:**
The checksum validation uses Python's `==` operator for string comparison:

```python
# reader.py:313
return h.hexdigest() == expected

# security.py:203
return doc.checksum == doc.compute_checksum()
```

This is vulnerable to timing side-channel attacks. The `==` operator short-circuits on the first differing character, so an attacker can potentially determine the correct checksum one character at a time by measuring response times.

Note: The HMAC verification in `security.py:70` correctly uses `hmac.compare_digest()` -- this issue is limited to checksum validation.

**Impact:**
- Theoretical timing side-channel (requires precise timing measurements)
- Low practical exploitability for a file format library
- Inconsistent security posture (HMAC uses constant-time, checksum does not)

**Remediation:**
```python
import hmac
return hmac.compare_digest(h.hexdigest(), expected)
```

---

### LOW: MBK-018 - Error Messages May Leak Internal Path Information

**ID:** MBK-018
**Severity:** LOW
**CVSS 3.1:** 3.1 (AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N)
**CWE:** CWE-209 (Generation of Error Message Containing Sensitive Information)
**Location:** `pfm/cli.py:111-113` (`cmd_validate`)

**Description:**
Error messages in the CLI include the full file path and exception messages:

```python
except Exception as e:
    print(f"FAIL: {path} parse error: {e}")
```

Exception messages from the parser or file system may include internal paths, stack traces, or system-specific information. While this is common in CLI tools, if the error output is captured and displayed by a web application, it could leak information.

**Impact:**
- Information disclosure of file paths and system details via error messages
- Low severity in CLI context, higher if output is displayed in web interfaces

**Remediation:**
1. Sanitize error messages to remove path components
2. Use generic error messages for user-facing output, log details internally
3. Catch specific exceptions rather than bare `Exception`

---

### LOW: MBK-019 - No File Permission Restrictions on Written Files

**ID:** MBK-019
**Severity:** LOW
**CVSS 3.1:** 3.3 (AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N)
**CWE:** CWE-732 (Incorrect Permission Assignment for Critical Resource)
**Location:** `pfm/writer.py:132-133` (`write`), `pfm/stream.py:83` (`__init__`)

**Description:**
Files are created with default system permissions (typically 0644 on Unix). For encrypted PFM files or files containing sensitive data, the default permissions may be too permissive, allowing other users on the system to read the contents.

The stream writer at `stream.py:83` uses `open(self.path, "wb")` which also inherits default umask permissions.

**Impact:**
- Sensitive encrypted or signed PFM files readable by other system users
- Potential information disclosure in shared hosting environments

**Remediation:**
1. For encrypted files, use restrictive permissions (0600):
```python
import os
fd = os.open(path, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
with os.fdopen(fd, 'wb') as f:
    f.write(data)
```
2. Add a `permissions` parameter to write methods
3. Document recommended file permissions for sensitive PFM files

---

## Handoff to Red Team

### Priority order for fixes:

**1. CRITICAL (Fix Immediately):**
- MBK-001: Arbitrary Attribute Injection via setattr - Replace with explicit allowlist
- MBK-002: Content Injection / Section Spoofing - Implement escaping or index-based boundaries
- MBK-003: Uncontrolled Memory Allocation - Add file size limits and index bounds validation

**2. HIGH (Fix Within 1 Sprint):**
- MBK-004: No AAD binding in AES-GCM encryption - Add header as AAD
- MBK-005: Path Traversal in CLI - Add path validation
- MBK-006: Missing checksum treated as valid - Invert the default
- MBK-007: Signature stripping attack - Add enforcement mechanism
- MBK-008: Race condition in crash recovery - Add file locking
- MBK-009: Unbounded integer parsing in index - Add bounds checks

**3. MEDIUM (Fix Within 2 Sprints):**
- MBK-010: Checksum excludes metadata - Include metadata in checksum
- MBK-011: Stream writer exposes unfinished file - Use .tmp extension pattern
- MBK-012: Signing message ambiguity - Use length-prefixed encoding
- MBK-013: Verify mutates document state - Use copy instead of mutation
- MBK-014: Unconstrained section count/name length - Add configurable limits
- MBK-015: No section name validation - Add validation regex
- MBK-016: Encrypted file header parsing - Add input validation

**4. LOW (Fix As Convenient):**
- MBK-017: Non-constant-time checksum comparison - Use hmac.compare_digest
- MBK-018: Error message information leakage - Sanitize error output
- MBK-019: Default file permissions too permissive - Use 0600 for sensitive files

---

## Attack Chain Analysis

The following chains combine multiple low/medium findings into higher-impact attack scenarios:

### Chain 1: Complete Document Forgery (MBK-006 + MBK-010 + MBK-001)
1. Start with a legitimate signed PFM file
2. Strip the checksum (MBK-006: missing checksum = valid)
3. Modify metadata to impersonate a different agent (MBK-010: checksum doesn't cover metadata)
4. Inject new attributes via setattr to manipulate internal state (MBK-001)
5. Result: A "valid" document that appears to come from a trusted source with manipulated internals

### Chain 2: Content Injection + Signature Bypass (MBK-002 + MBK-007)
1. Intercept a signed PFM document
2. Strip the signature fields (MBK-007: no enforcement mechanism)
3. Inject sections via content markers (MBK-002: no escaping)
4. Result: A document with attacker-controlled sections that appears merely "unsigned" rather than tampered

### Chain 3: Denial of Service Amplification (MBK-003 + MBK-014)
1. Craft a file with 1M sections with long names (MBK-014: no limits)
2. Each section triggers full parsing and checksum computation (MBK-003: no size limits)
3. Result: A small file that causes massive CPU and memory consumption

---

## Next Steps

Recommend: `@red-team fix pfm/`

The Critical findings (MBK-001, MBK-002, MBK-003) should be addressed before any public release. The cryptographic issues (MBK-004, MBK-006, MBK-007) should be addressed before the security module is advertised as production-ready.

---

*Report generated by Mr BlackKeys - Lead Penetration Tester*
*Classification: CONFIDENTIAL - For development team use only*
