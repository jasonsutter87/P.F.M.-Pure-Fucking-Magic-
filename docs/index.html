<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; img-src data:; connect-src 'none'; font-src 'none'; object-src 'none'; base-uri 'none'; form-action 'none';">
<title>PFM Viewer &amp; Converter -- Pure Fucking Magic</title>
<meta name="description" content="View and convert .pfm AI agent output files in your browser. Drag and drop, no upload, fully client-side.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x2728;</text></svg>">
<style>
/* ===== Reset & Variables ===== */
:root {
  --bg:          #0d1117;
  --bg-surface:  #161b22;
  --bg-card:     #1c2128;
  --bg-hover:    #262c36;
  --bg-active:   #1f6feb22;
  --text:        #e6edf3;
  --text-muted:  #7d8590;
  --text-dim:    #484f58;
  --accent:      #58a6ff;
  --accent-hover:#79c0ff;
  --green:       #3fb950;
  --green-bg:    #3fb95018;
  --red:         #f85149;
  --red-bg:      #f8514918;
  --orange:      #d29922;
  --purple:      #bc8cff;
  --border:      #30363d;
  --border-focus:#58a6ff;
  --radius:      8px;
  --radius-lg:   12px;
  --font:        -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  --mono:        'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  --shadow:      0 3px 12px rgba(0,0,0,.4);
  --transition:  150ms ease;
}
.light {
  --bg:          #ffffff;
  --bg-surface:  #f6f8fa;
  --bg-card:     #ffffff;
  --bg-hover:    #eaeef2;
  --bg-active:   #ddf4ff;
  --text:        #1f2328;
  --text-muted:  #656d76;
  --text-dim:    #b1bac4;
  --accent:      #0969da;
  --accent-hover:#0550ae;
  --green:       #1a7f37;
  --green-bg:    #dafbe1;
  --red:         #cf222e;
  --red-bg:      #ffebe9;
  --orange:      #9a6700;
  --purple:      #8250df;
  --border:      #d0d7de;
  --border-focus:#0969da;
  --shadow:      0 3px 12px rgba(0,0,0,.12);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { height: 100%; }
body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  height: 100%;
  overflow: hidden;
  font-size: 14px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}
button { font-family: inherit; cursor: pointer; }
input { font-family: inherit; }

/* ===== Landing Screen ===== */
#landing {
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100%;
  overflow-y: auto;
  padding: 48px 24px 24px;
  text-align: center;
  transition: opacity var(--transition);
}
#landing::before,
#landing::after {
  content: '';
  flex: 1;
}
#landing.hidden { display: none; }

.landing-logo {
  font-size: 64px;
  margin-bottom: 16px;
  filter: drop-shadow(0 0 24px rgba(88,166,255,.3));
}
.landing-title {
  font-size: 40px;
  font-weight: 800;
  letter-spacing: -1px;
  background: linear-gradient(135deg, var(--accent), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}
.landing-subtitle {
  font-size: 18px;
  color: var(--text-muted);
  max-width: 480px;
  margin-bottom: 40px;
}

/* Drop Zone */
.drop-zone {
  width: 100%;
  max-width: 520px;
  border: 2px dashed var(--border);
  border-radius: var(--radius-lg);
  padding: 48px 32px;
  transition: all var(--transition);
  background: var(--bg-surface);
  cursor: pointer;
  position: relative;
}
.drop-zone:hover, .drop-zone.dragover {
  border-color: var(--accent);
  background: var(--bg-active);
}
.drop-zone.dragover {
  transform: scale(1.02);
  box-shadow: 0 0 0 4px rgba(88,166,255,.15);
}
.drop-zone-icon {
  font-size: 40px;
  margin-bottom: 12px;
  opacity: .7;
}
.drop-zone-text {
  font-size: 16px;
  color: var(--text);
  margin-bottom: 4px;
}
.drop-zone-hint {
  font-size: 13px;
  color: var(--text-muted);
}
.drop-zone input[type="file"] {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

.landing-or {
  color: var(--text-dim);
  margin: 24px 0;
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.demo-btn {
  padding: 10px 28px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: var(--radius);
  font-size: 15px;
  font-weight: 600;
  transition: all var(--transition);
}
.demo-btn:hover {
  background: var(--accent-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow);
}

.landing-footer {
  position: absolute;
  bottom: 24px;
  font-size: 12px;
  color: var(--text-dim);
}
.landing-footer a {
  color: var(--text-muted);
  text-decoration: none;
}
.landing-footer a:hover { color: var(--accent); }

/* Ecosystem cards */
.ecosystem {
  display: flex;
  gap: 12px;
  margin-top: 32px;
  max-width: 640px;
  width: 100%;
  flex-wrap: wrap;
  justify-content: center;
}
.eco-card {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  text-decoration: none;
  color: var(--text);
  transition: all var(--transition);
  min-width: 180px;
  flex: 1;
}
.eco-card:hover {
  border-color: var(--accent);
  background: var(--bg-active);
  transform: translateY(-1px);
}
.eco-icon { font-size: 20px; flex-shrink: 0; }
.eco-info { text-align: left; }
.eco-label { font-size: 13px; font-weight: 600; }
.eco-cmd {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--mono);
}

/* Install snippet */
.install-row {
  display: flex;
  gap: 12px;
  margin-top: 20px;
  max-width: 520px;
  width: 100%;
}
.install-card {
  flex: 1;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px 14px;
  text-align: left;
  position: relative;
  cursor: pointer;
  transition: all var(--transition);
}
.install-card:hover {
  border-color: var(--accent);
}
.install-card::after {
  content: 'Click to copy';
  position: absolute;
  top: 4px;
  right: 8px;
  font-size: 9px;
  color: var(--text-dim);
  opacity: 0;
  transition: opacity var(--transition);
}
.install-card:hover::after { opacity: 1; }
.install-card.copied::after { content: 'Copied!'; color: var(--green); opacity: 1; }
.install-lang {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: .8px;
  color: var(--text-dim);
  font-weight: 600;
  margin-bottom: 4px;
}
.install-cmd {
  font-family: var(--mono);
  font-size: 13px;
  color: var(--accent);
}

/* ===== Viewer Screen ===== */
#viewer {
  display: none;
  height: 100%;
  flex-direction: column;
}
#viewer.active {
  display: flex;
}

/* Top bar */
.topbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 16px;
  height: 48px;
  min-height: 48px;
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
}
.topbar-brand {
  font-weight: 700;
  color: var(--accent);
  font-size: 15px;
  margin-right: 4px;
}
.topbar-filename {
  font-size: 13px;
  color: var(--text-muted);
  font-family: var(--mono);
}
.topbar-spacer { flex: 1; }
.topbar-btn {
  padding: 5px 12px;
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-muted);
  font-size: 12px;
  transition: all var(--transition);
}
a.topbar-btn { text-decoration: none; }
.topbar-btn:hover {
  background: var(--bg-hover);
  color: var(--text);
  border-color: var(--text-dim);
}
.topbar-btn.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
.topbar-btn.primary:hover {
  background: var(--accent-hover);
}

/* Layout */
.layout {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* Sidebar */
.sidebar {
  width: 288px;
  min-width: 288px;
  background: var(--bg-surface);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.sidebar-section {
  border-bottom: 1px solid var(--border);
}
.sidebar-section-header {
  padding: 10px 16px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: .8px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  user-select: none;
}
.sidebar-section-header:hover { color: var(--text); }
.sidebar-section-body { padding: 0 16px 12px; }

/* Checksum badge */
.badge {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
}
.badge.valid { color: var(--green); background: var(--green-bg); }
.badge.invalid { color: var(--red); background: var(--red-bg); }

/* Meta */
.meta-grid {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.meta-row {
  display: flex;
  flex-direction: column;
  gap: 1px;
}
.meta-key {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: .5px;
  color: var(--text-dim);
  font-weight: 600;
}
.meta-val {
  font-size: 12px;
  color: var(--text);
  font-family: var(--mono);
  word-break: break-all;
  line-height: 1.4;
}

/* Search */
.search-wrap {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
}
.search-input {
  width: 100%;
  padding: 6px 10px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text);
  font-size: 13px;
  outline: none;
  transition: border-color var(--transition);
}
.search-input::placeholder { color: var(--text-dim); }
.search-input:focus { border-color: var(--border-focus); }

/* Section list */
.section-list {
  flex: 1;
  overflow-y: auto;
  padding: 4px 0;
}
.section-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 7px 16px;
  cursor: pointer;
  border-left: 3px solid transparent;
  transition: all 80ms ease;
  user-select: none;
}
.section-item:hover {
  background: var(--bg-hover);
}
.section-item.active {
  background: var(--bg-active);
  border-left-color: var(--accent);
}
.section-item-name {
  font-size: 13px;
  font-weight: 500;
}
.section-item.active .section-item-name {
  color: var(--accent);
}
.section-item-size {
  font-size: 11px;
  color: var(--text-dim);
  font-family: var(--mono);
}

/* Main content */
.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
}
.content-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--bg-surface);
  min-height: 44px;
}
.content-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent);
}
.content-meta {
  font-size: 12px;
  color: var(--text-dim);
  font-family: var(--mono);
}
.content-header-spacer { flex:1; }
.content-wrap-toggle {
  font-size: 11px;
  color: var(--text-muted);
  cursor: pointer;
  padding: 3px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: transparent;
  user-select: none;
}
.content-wrap-toggle:hover { background: var(--bg-hover); }
.content-wrap-toggle.active { background: var(--bg-active); border-color: var(--accent); color: var(--accent); }

.content-body {
  flex: 1;
  overflow: auto;
  padding: 20px;
}
.content-pre {
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.7;
  color: var(--text);
  tab-size: 4;
  white-space: pre;
  margin: 0;
}
.content-pre.wrap {
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* Line numbers gutter */
.code-container {
  display: flex;
}
.line-numbers {
  padding-right: 16px;
  text-align: right;
  user-select: none;
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.7;
  border-right: 1px solid var(--border);
  margin-right: 16px;
  min-width: 40px;
  flex-shrink: 0;
}

/* Empty state in content */
.content-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-dim);
  font-size: 15px;
}

/* ===== Keyboard shortcut hints ===== */
.kbd {
  display: inline-block;
  padding: 2px 6px;
  font-size: 11px;
  font-family: var(--mono);
  background: var(--bg-hover);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-muted);
  line-height: 1.4;
}

/* ===== Scrollbar ===== */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb {
  background: var(--text-dim);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

/* ===== Mode Tabs ===== */
.mode-tabs {
  display: flex;
  gap: 0;
  margin-bottom: 28px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
}
.mode-tab {
  flex: 1;
  padding: 10px 24px;
  font-size: 14px;
  font-weight: 600;
  border: none;
  background: transparent;
  color: var(--text-muted);
  transition: all var(--transition);
  cursor: pointer;
}
.mode-tab:hover { color: var(--text); background: var(--bg-hover); }
.mode-tab.active {
  color: var(--accent);
  background: var(--bg-active);
  box-shadow: inset 0 -2px 0 var(--accent);
}

/* Tab Panels */
.tab-panel { display: none; width: 100%; max-width: 520px; flex-direction: column; align-items: center; }
.tab-panel.active { display: flex; }

/* Format Cards */
.format-cards {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 20px;
  width: 100%;
  max-width: 520px;
}
.format-card {
  padding: 12px 16px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  text-align: left;
}
.format-card-ext {
  font-family: var(--mono);
  font-size: 15px;
  font-weight: 700;
  color: var(--accent);
  margin-bottom: 2px;
}
.format-card-desc {
  font-size: 12px;
  color: var(--text-muted);
}

/* ===== Converter Result Screen ===== */
#converter {
  display: none;
  height: 100%;
  flex-direction: column;
}
#converter.active { display: flex; }

.convert-result {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.convert-info {
  padding: 16px 20px;
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}
.convert-stat {
  display: flex;
  flex-direction: column;
  gap: 1px;
}
.convert-stat-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: .5px;
  color: var(--text-dim);
  font-weight: 600;
}
.convert-stat-val {
  font-size: 13px;
  color: var(--text);
  font-family: var(--mono);
}
.convert-preview {
  flex: 1;
  overflow: auto;
  padding: 20px;
}
.convert-preview pre {
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.6;
  white-space: pre;
  color: var(--text);
  margin: 0;
}

/* ===== Page Screens (Benchmarks, Audits, TOS) ===== */
.page-screen {
  display: none;
  height: 100%;
  flex-direction: column;
  overflow: hidden;
}
.page-screen.active { display: flex; }
.page-body {
  flex: 1;
  overflow-y: auto;
  padding: 48px 24px;
}
.page-inner {
  max-width: 880px;
  margin: 0 auto;
}
.page-hero {
  text-align: center;
  margin-bottom: 48px;
}
.page-title {
  font-size: 36px;
  font-weight: 800;
  letter-spacing: -1px;
  background: linear-gradient(135deg, var(--accent), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}
.page-subtitle {
  font-size: 16px;
  color: var(--text-muted);
}

/* Scorecard */
.scorecard {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 12px;
  margin: 24px 0 40px;
}
.score-card {
  padding: 20px 12px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  text-align: center;
}
.score-card.champion {
  border-color: var(--accent);
  background: var(--bg-active);
}
.score-format { font-size: 18px; font-weight: 700; margin-bottom: 4px; }
.score-val { font-size: 28px; font-weight: 800; font-family: var(--mono); }
.score-card.champion .score-val { color: var(--accent); }
.score-label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: .5px; }

/* Section headings */
.section-heading {
  font-size: 22px;
  font-weight: 700;
  margin: 40px 0 16px;
  color: var(--text);
}

/* Benchmark tables */
.bench-table {
  width: 100%;
  border-collapse: collapse;
  margin: 16px 0 32px;
  font-size: 13px;
}
.bench-table th {
  text-align: left;
  padding: 10px 14px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: .5px;
  color: var(--text-muted);
  font-weight: 600;
}
.bench-table td {
  padding: 10px 14px;
  border: 1px solid var(--border);
  font-family: var(--mono);
}
.bench-table tr:hover td { background: var(--bg-hover); }
.bench-table .winner { color: var(--green); font-weight: 600; }
.bench-table .highlight td { background: var(--bg-active); }

/* Bar chart */
.bar-chart { margin: 16px 0 32px; }
.bar-row { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
.bar-label { width: 50px; font-size: 13px; font-weight: 600; text-align: right; }
.bar-track { flex: 1; height: 28px; background: var(--bg-surface); border-radius: 4px; overflow: hidden; }
.bar-fill {
  height: 100%;
  border-radius: 4px;
  display: flex;
  align-items: center;
  padding-left: 10px;
  font-size: 12px;
  font-weight: 600;
  font-family: var(--mono);
  color: #fff;
  min-width: 72px;
}
.bar-fill.pfm-bar { background: var(--accent); }
.bar-fill.json-bar { background: var(--purple); }
.bar-fill.md-bar { background: var(--green); }
.bar-fill.txt-bar { background: var(--orange); }
.bar-fill.csv-bar { background: var(--red); }

/* Audit styles */
.audit-tabs {
  display: flex;
  gap: 0;
  margin-bottom: 32px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
}
.audit-tab {
  flex: 1;
  padding: 12px 20px;
  font-size: 14px;
  font-weight: 600;
  border: none;
  background: transparent;
  color: var(--text-muted);
  transition: all var(--transition);
  cursor: pointer;
}
.audit-tab:hover { color: var(--text); background: var(--bg-hover); }
.audit-tab.active {
  color: var(--accent);
  background: var(--bg-active);
  box-shadow: inset 0 -2px 0 var(--accent);
}
.audit-panel { display: none; }
.audit-panel.active { display: block; }

.audit-report h3 { font-size: 18px; font-weight: 700; margin: 28px 0 12px; color: var(--text); }
.audit-report h4 { font-size: 15px; font-weight: 600; margin: 20px 0 8px; color: var(--text-muted); }
.audit-report p { margin: 8px 0; line-height: 1.7; color: var(--text); }
.audit-report ul, .audit-report ol { margin: 8px 0; padding-left: 24px; }
.audit-report li { margin: 4px 0; line-height: 1.6; }
.audit-report code {
  font-family: var(--mono);
  font-size: 12px;
  background: var(--bg-surface);
  padding: 2px 6px;
  border-radius: 3px;
  border: 1px solid var(--border);
}
.audit-report pre {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  overflow-x: auto;
  margin: 12px 0;
  font-family: var(--mono);
  font-size: 13px;
  line-height: 1.5;
}
.audit-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0 24px;
  font-size: 13px;
}
.audit-table th {
  text-align: left;
  padding: 8px 12px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  font-weight: 600;
  color: var(--text-muted);
}
.audit-table td { padding: 8px 12px; border: 1px solid var(--border); }
.severity-crit { color: var(--red); font-weight: 700; }
.severity-high { color: var(--orange); font-weight: 700; }
.severity-med { color: #d29922; font-weight: 600; }
.severity-low { color: var(--text-muted); }
.status-pass { color: var(--green); font-weight: 600; }

.grade-badge {
  display: inline-block;
  padding: 4px 16px;
  background: var(--green-bg);
  color: var(--green);
  border-radius: 20px;
  font-size: 18px;
  font-weight: 800;
  margin: 8px 0;
}
.cert-box {
  border: 2px solid var(--green);
  border-radius: var(--radius-lg);
  padding: 24px;
  text-align: center;
  margin: 24px 0;
  background: var(--green-bg);
}
.cert-box h3 { color: var(--green); font-size: 22px; margin: 0 0 8px; }

/* TOS styles */
.tos-content h3 { font-size: 18px; font-weight: 700; margin: 32px 0 12px; color: var(--text); }
.tos-content p { margin: 8px 0; line-height: 1.7; color: var(--text); }
.tos-content ul { margin: 8px 0; padding-left: 24px; }
.tos-content li { margin: 4px 0; line-height: 1.6; }
.tos-updated { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; }

/* ===== Responsive ===== */
@media (max-width: 768px) {
  .sidebar { width: 220px; min-width: 220px; }
  .landing-title { font-size: 28px; }
}
@media (max-width: 600px) {
  .layout { flex-direction: column; }
  .sidebar { width: 100%; min-width: unset; max-height: 45%; border-right: none; border-bottom: 1px solid var(--border); }
}
</style>
</head>
<body>

<!-- ========== LANDING ========== -->
<div id="landing">
  <div class="landing-logo">&#x2728;</div>
  <h1 class="landing-title">PFM</h1>
  <p class="landing-subtitle">View and convert AI agent output files in your browser. Everything runs client-side â€” your files never leave your machine.</p>

  <!-- Mode Tabs -->
  <div class="mode-tabs">
    <button class="mode-tab active" id="tab-view" onclick="switchTab('view')">View .pfm</button>
    <button class="mode-tab" id="tab-convert" onclick="switchTab('convert')">Convert to .pfm</button>
  </div>

  <!-- View Mode -->
  <div class="tab-panel active" id="panel-view">
    <div class="drop-zone" id="drop-zone">
      <input type="file" id="file-input" accept=".pfm">
      <div class="drop-zone-icon">&#128194;</div>
      <div class="drop-zone-text">Drop a <strong>.pfm</strong> file here</div>
      <div class="drop-zone-hint">or click to browse</div>
    </div>

    <div class="landing-or">or</div>

    <button class="demo-btn" id="demo-btn">Load Demo File</button>
  </div>

  <!-- Convert Mode -->
  <div class="tab-panel" id="panel-convert">
    <div class="drop-zone" id="convert-drop-zone">
      <input type="file" id="convert-file-input" accept=".json,.csv,.txt,.md,.markdown">
      <div class="drop-zone-icon">&#x1F504;</div>
      <div class="drop-zone-text">Drop a file to convert to <strong>.pfm</strong></div>
      <div class="drop-zone-hint">Supports JSON, CSV, TXT, and Markdown</div>
    </div>

    <div class="format-cards">
      <div class="format-card">
        <div class="format-card-ext">.json</div>
        <div class="format-card-desc">Structured data with sections array</div>
      </div>
      <div class="format-card">
        <div class="format-card-ext">.csv</div>
        <div class="format-card-desc">section_name, content columns</div>
      </div>
      <div class="format-card">
        <div class="format-card-ext">.txt</div>
        <div class="format-card-desc">Plain text as single content section</div>
      </div>
      <div class="format-card">
        <div class="format-card-ext">.md</div>
        <div class="format-card-desc">H2 headings become sections</div>
      </div>
    </div>
  </div>

  <!-- Install snippets -->
  <div class="install-row">
    <div class="install-card" onclick="copyInstall(this, 'npm install pfm')">
      <div class="install-lang">JavaScript / TypeScript</div>
      <div class="install-cmd">npm install pfm</div>
    </div>
    <div class="install-card" onclick="copyInstall(this, 'pip install pfm')">
      <div class="install-lang">Python</div>
      <div class="install-cmd">pip install pfm</div>
    </div>
  </div>

  <!-- Ecosystem links -->
  <div class="ecosystem">
    <a class="eco-card" href="https://www.npmjs.com/package/pfm" target="_blank" rel="noopener">
      <span class="eco-icon">&#x1F4E6;</span>
      <span class="eco-info">
        <span class="eco-label">npm</span>
        <span class="eco-cmd">pfm</span>
      </span>
    </a>
    <a class="eco-card" href="https://pypi.org/project/pfm/" target="_blank" rel="noopener">
      <span class="eco-icon">&#x1F40D;</span>
      <span class="eco-info">
        <span class="eco-label">PyPI</span>
        <span class="eco-cmd">pfm</span>
      </span>
    </a>
    <a class="eco-card" href="https://github.com/jasonsutter87/P.F.M.-Pure-Fucking-Magic-" target="_blank" rel="noopener">
      <span class="eco-icon">&#x1F4BB;</span>
      <span class="eco-info">
        <span class="eco-label">GitHub</span>
        <span class="eco-cmd">Source &amp; Docs</span>
      </span>
    </a>
  </div>

  <!-- Resources -->
  <div class="ecosystem" style="margin-top:20px;">
    <a class="eco-card" href="#benchmarks">
      <span class="eco-icon">&#x1F4CA;</span>
      <span class="eco-info">
        <span class="eco-label">Benchmarks</span>
        <span class="eco-cmd">Speed, Size, Security</span>
      </span>
    </a>
    <a class="eco-card" href="#audits">
      <span class="eco-icon">&#x1F6E1;&#xFE0F;</span>
      <span class="eco-info">
        <span class="eco-label">Security Audits</span>
        <span class="eco-cmd">Black Team Reports</span>
      </span>
    </a>
    <a class="eco-card" href="#tos">
      <span class="eco-icon">&#x1F4DC;</span>
      <span class="eco-info">
        <span class="eco-label">Terms</span>
        <span class="eco-cmd">Terms of Service</span>
      </span>
    </a>
  </div>

  <div class="landing-footer">
    <a href="https://github.com/jasonsutter87/P.F.M.-Pure-Fucking-Magic-">PFM</a> &mdash; Pure Fucking Magic. AI agent output container format.
  </div>
</div>

<!-- ========== VIEWER ========== -->
<div id="viewer">
  <div class="topbar">
    <span class="topbar-brand">PFM</span>
    <span class="topbar-filename" id="v-filename"></span>
    <span class="topbar-spacer"></span>
    <button class="topbar-btn" id="btn-shortcuts" title="Keyboard shortcuts">&#9000; Shortcuts</button>
    <button class="topbar-btn" id="btn-export-json">JSON</button>
    <button class="topbar-btn" id="btn-export-md">MD</button>
    <button class="topbar-btn" id="btn-export-csv">CSV</button>
    <button class="topbar-btn" id="btn-export-txt">TXT</button>
    <button class="topbar-btn" id="btn-theme">Theme</button>
    <a class="topbar-btn" href="https://github.com/jasonsutter87/P.F.M.-Pure-Fucking-Magic-" target="_blank" rel="noopener">GitHub</a>
    <button class="topbar-btn primary" id="btn-open-new">Open File</button>
  </div>

  <div class="layout">
    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Checksum -->
      <div class="sidebar-section">
        <div class="sidebar-section-header">
          <span>Status</span>
          <span class="badge" id="v-checksum-badge"></span>
        </div>
      </div>

      <!-- Metadata -->
      <div class="sidebar-section" id="meta-section">
        <div class="sidebar-section-header" id="meta-toggle">
          <span>Metadata</span>
          <span id="meta-count"></span>
        </div>
        <div class="sidebar-section-body" id="v-meta"></div>
      </div>

      <!-- Search -->
      <div class="search-wrap">
        <input type="text" class="search-input" id="v-search" placeholder="Filter sections... ( / )">
      </div>

      <!-- Section List -->
      <div class="section-list" id="v-section-list"></div>
    </div>

    <!-- Content -->
    <div class="content-area">
      <div class="content-header">
        <span class="content-title" id="v-content-title">Select a section</span>
        <span class="content-meta" id="v-content-meta"></span>
        <span class="content-header-spacer"></span>
        <button class="content-wrap-toggle active" id="btn-wrap" title="Toggle word wrap">Wrap</button>
      </div>
      <div class="content-body" id="v-content-body">
        <div class="content-empty">Select a section from the sidebar</div>
      </div>
    </div>
  </div>
</div>

<!-- ========== CONVERTER RESULT ========== -->
<div id="converter">
  <div class="topbar">
    <span class="topbar-brand">PFM</span>
    <span class="topbar-filename" id="c-filename"></span>
    <span class="topbar-spacer"></span>
    <button class="topbar-btn" id="btn-convert-view" title="Open in viewer">View in Viewer</button>
    <button class="topbar-btn primary" id="btn-convert-download">Download .pfm</button>
    <button class="topbar-btn" id="btn-convert-back">Back</button>
  </div>
  <div class="convert-result">
    <div class="convert-info">
      <div class="convert-stat">
        <span class="convert-stat-label">Source Format</span>
        <span class="convert-stat-val" id="c-source-fmt"></span>
      </div>
      <div class="convert-stat">
        <span class="convert-stat-label">Sections</span>
        <span class="convert-stat-val" id="c-sections"></span>
      </div>
      <div class="convert-stat">
        <span class="convert-stat-label">Meta Fields</span>
        <span class="convert-stat-val" id="c-meta"></span>
      </div>
      <div class="convert-stat">
        <span class="convert-stat-label">Output Size</span>
        <span class="convert-stat-val" id="c-size"></span>
      </div>
    </div>
    <div class="convert-preview">
      <pre id="c-preview"></pre>
    </div>
  </div>
</div>

<!-- ========== SHORTCUTS MODAL ========== -->
<div id="shortcuts-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:100;display:none;align-items:center;justify-content:center;">
  <div style="background:var(--bg-card);border:1px solid var(--border);border-radius:var(--radius-lg);padding:24px 32px;max-width:400px;width:90%;box-shadow:var(--shadow);">
    <h3 style="margin-bottom:16px;font-size:16px;">Keyboard Shortcuts</h3>
    <table style="width:100%;font-size:13px;border-collapse:collapse;">
      <tr><td style="padding:4px 0;"><span class="kbd">j</span> / <span class="kbd">&darr;</span></td><td>Next section</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">k</span> / <span class="kbd">&uarr;</span></td><td>Previous section</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">/</span></td><td>Focus search</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">Esc</span></td><td>Clear search / close modal</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">w</span></td><td>Toggle word wrap</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">t</span></td><td>Toggle theme</td></tr>
      <tr><td style="padding:4px 0;"><span class="kbd">o</span></td><td>Open new file</td></tr>
    </table>
    <button class="topbar-btn" style="margin-top:16px;width:100%;" onclick="closeShortcuts()">Close</button>
  </div>
</div>

<!-- ========== BENCHMARKS PAGE ========== -->
<div id="page-benchmarks" class="page-screen">
  <div class="topbar">
    <a class="topbar-brand" href="#" style="text-decoration:none;">PFM</a>
    <span class="topbar-filename">Benchmarks</span>
    <span class="topbar-spacer"></span>
    <button class="topbar-btn" id="btn-theme-bench" onclick="toggleTheme()">Theme</button>
    <a class="topbar-btn" href="#">Home</a>
  </div>
  <div class="page-body">
    <div class="page-inner">
      <div class="page-hero">
        <h1 class="page-title">Format Benchmarks</h1>
        <p class="page-subtitle">Same content, 5 formats. Measured across speed, size, indexability, and security.</p>
      </div>

      <!-- Scorecard -->
      <div class="scorecard">
        <div class="score-card champion">
          <div class="score-format">PFM</div>
          <div class="score-val">15.5</div>
          <div class="score-label">/ 20</div>
        </div>
        <div class="score-card">
          <div class="score-format">JSON</div>
          <div class="score-val">12.5</div>
          <div class="score-label">/ 20</div>
        </div>
        <div class="score-card">
          <div class="score-format">TXT</div>
          <div class="score-val">12.5</div>
          <div class="score-label">/ 20</div>
        </div>
        <div class="score-card">
          <div class="score-format">MD</div>
          <div class="score-val">12.0</div>
          <div class="score-label">/ 20</div>
        </div>
        <div class="score-card">
          <div class="score-format">CSV</div>
          <div class="score-val">10.5</div>
          <div class="score-label">/ 20</div>
        </div>
      </div>

      <!-- Size -->
      <h2 class="section-heading">1. File Size</h2>
      <p style="color:var(--text-muted);margin-bottom:16px;">PFM adds just 4.5% overhead for its metadata, index, and structure. JSON's escaping and quoting costs 11.5%.</p>
      <table class="bench-table">
        <thead><tr><th>Format</th><th>Raw</th><th>Gzipped</th><th>Compression</th><th>Overhead</th></tr></thead>
        <tbody>
          <tr><td>TXT</td><td>9,188 B</td><td>3,859 B</td><td>42.0%</td><td class="winner">baseline</td></tr>
          <tr><td>CSV</td><td>9,227 B</td><td>3,879 B</td><td>42.0%</td><td>+0.4%</td></tr>
          <tr><td>MD</td><td>9,371 B</td><td>3,992 B</td><td>42.6%</td><td>+2.0%</td></tr>
          <tr class="highlight"><td>PFM</td><td>9,604 B</td><td>4,110 B</td><td>42.8%</td><td>+4.5%</td></tr>
          <tr><td>JSON</td><td>10,244 B</td><td>4,153 B</td><td>40.5%</td><td>+11.5%</td></tr>
        </tbody>
      </table>

      <!-- Speed -->
      <h2 class="section-heading">2. Speed</h2>
      <p style="color:var(--text-muted);margin-bottom:16px;">PFM's indexed section access is 12&ndash;25x faster than every other format. JSON wins full parse via C-optimized <code style="font-family:var(--mono);font-size:12px;background:var(--bg-surface);padding:2px 6px;border-radius:3px;border:1px solid var(--border);">json.loads()</code>.</p>

      <h3 style="font-size:15px;font-weight:600;margin:20px 0 12px;color:var(--text-muted);">Targeted Section Access &mdash; &ldquo;License&rdquo; (10,000 iterations)</h3>
      <div class="bar-chart">
        <div class="bar-row">
          <span class="bar-label">PFM</span>
          <div class="bar-track"><div class="bar-fill pfm-bar" style="width:8%;">4.2 &micro;s</div></div>
        </div>
        <div class="bar-row">
          <span class="bar-label">JSON</span>
          <div class="bar-track"><div class="bar-fill json-bar" style="width:50%;">52.8 &micro;s</div></div>
        </div>
        <div class="bar-row">
          <span class="bar-label">MD</span>
          <div class="bar-track"><div class="bar-fill md-bar" style="width:67%;">70.0 &micro;s</div></div>
        </div>
        <div class="bar-row">
          <span class="bar-label">TXT</span>
          <div class="bar-track"><div class="bar-fill txt-bar" style="width:75%;">78.7 &micro;s</div></div>
        </div>
        <div class="bar-row">
          <span class="bar-label">CSV</span>
          <div class="bar-track"><div class="bar-fill csv-bar" style="width:100%;">104.9 &micro;s</div></div>
        </div>
      </div>

      <table class="bench-table">
        <thead><tr><th>Operation</th><th>PFM</th><th>JSON</th><th>CSV</th><th>MD</th><th>TXT</th></tr></thead>
        <tbody>
          <tr><td>Full file read</td><td>31.5 &micro;s</td><td class="winner">27.0 &micro;s</td><td>30.1 &micro;s</td><td>30.6 &micro;s</td><td>41.8 &micro;s</td></tr>
          <tr><td>File ID (64 bytes)</td><td>20.7 &micro;s</td><td>19.8 &micro;s</td><td>20.8 &micro;s</td><td class="winner">15.4 &micro;s</td><td>21.1 &micro;s</td></tr>
          <tr><td>Full parse</td><td>129.7 &micro;s</td><td class="winner">47.2 &micro;s</td><td>106.9 &micro;s</td><td>77.9 &micro;s</td><td>79.1 &micro;s</td></tr>
          <tr><td>Section access</td><td class="winner">4.2 &micro;s</td><td>52.8 &micro;s</td><td>104.9 &micro;s</td><td>70.0 &micro;s</td><td>78.7 &micro;s</td></tr>
        </tbody>
      </table>

      <!-- Indexability -->
      <h2 class="section-heading">3. Indexability</h2>
      <p style="color:var(--text-muted);margin-bottom:16px;">PFM is the only format with a pre-computed byte-offset index. All others require full-file scanning to locate a section.</p>
      <table class="bench-table">
        <thead><tr><th>Format</th><th>Section Index</th><th>Access Pattern</th><th>Sections Found</th><th>Searchable</th></tr></thead>
        <tbody>
          <tr class="highlight"><td>PFM</td><td class="winner">Yes (byte offsets)</td><td class="winner">O(1) seek</td><td>10</td><td>grep</td></tr>
          <tr><td>JSON</td><td>No</td><td>O(n) scan</td><td>10</td><td>jq</td></tr>
          <tr><td>CSV</td><td>No</td><td>O(n) scan</td><td>10</td><td>Partial</td></tr>
          <tr><td>MD</td><td>No</td><td>O(n) scan</td><td>10</td><td>grep</td></tr>
          <tr><td>TXT</td><td>No</td><td>O(n) scan</td><td>10</td><td>grep</td></tr>
        </tbody>
      </table>

      <!-- Security -->
      <h2 class="section-heading">4. Security</h2>
      <p style="color:var(--text-muted);margin-bottom:16px;">PFM is the only text format with built-in integrity verification, signing, and encryption. Every other format has zero security features.</p>
      <table class="bench-table">
        <thead><tr><th>Feature</th><th>PFM</th><th>JSON</th><th>CSV</th><th>MD</th><th>TXT</th></tr></thead>
        <tbody>
          <tr><td>Integrity</td><td class="winner">SHA-256</td><td>None</td><td>None</td><td>None</td><td>None</td></tr>
          <tr><td>Tamper Detection</td><td class="winner">Built-in</td><td>None</td><td>None</td><td>None</td><td>None</td></tr>
          <tr><td>Signing</td><td class="winner">HMAC-SHA256</td><td>None</td><td>None</td><td>None</td><td>None</td></tr>
          <tr><td>Encryption</td><td class="winner">AES-256-GCM</td><td>None</td><td>None</td><td>None</td><td>None</td></tr>
          <tr><td>Provenance</td><td class="winner">Full metadata</td><td>Manual</td><td>None</td><td>None</td><td>None</td></tr>
        </tbody>
      </table>

      <div style="margin-top:48px;padding:20px;background:var(--bg-surface);border:1px solid var(--border);border-radius:var(--radius-lg);text-align:center;">
        <p style="color:var(--text-muted);font-size:13px;margin:0;">Benchmarked with Python 3.13 on macOS. 10,000 iterations per test. Same README content across all 5 formats.</p>
      </div>
    </div>
  </div>
</div>

<!-- ========== AUDITS PAGE ========== -->
<div id="page-audits" class="page-screen">
  <div class="topbar">
    <a class="topbar-brand" href="#" style="text-decoration:none;">PFM</a>
    <span class="topbar-filename">Security Audits</span>
    <span class="topbar-spacer"></span>
    <button class="topbar-btn" onclick="toggleTheme()">Theme</button>
    <a class="topbar-btn" href="#">Home</a>
  </div>
  <div class="page-body">
    <div class="page-inner">
      <div class="page-hero">
        <h1 class="page-title">Security Audits</h1>
        <p class="page-subtitle">Independent offensive security assessments by Black Team. Full penetration testing, APT simulation, and chaos engineering.</p>
      </div>

      <!-- Audit Tabs -->
      <div class="audit-tabs">
        <button class="audit-tab active" id="audit-tab-full" onclick="switchAuditTab('full')">Black Team Report</button>
        <button class="audit-tab" id="audit-tab-summit" onclick="switchAuditTab('summit')">Hacking Summit</button>
      </div>

      <!-- Full Report Panel -->
      <div class="audit-panel active" id="audit-panel-full">
        <div class="audit-report">
          <h3>Black Team Offensive Security Assessment</h3>
          <p style="color:var(--text-muted);">Project: PFM &bull; Date: 2026-02-17 &bull; Scope: Python, JS/TS, Chrome Extension, VS Code Extension, SPA &bull; Agents: mr-blackkeys, specter, cashout, burn1t</p>

          <h4>Executive Summary</h4>
          <table class="audit-table">
            <thead><tr><th>Severity</th><th>Found</th><th>Fixed</th><th>Open</th></tr></thead>
            <tbody>
              <tr><td class="severity-crit">CRITICAL</td><td>5</td><td>5</td><td>0</td></tr>
              <tr><td class="severity-high">HIGH</td><td>5</td><td>5</td><td>0</td></tr>
              <tr><td class="severity-med">MEDIUM</td><td>10</td><td>10</td><td>0</td></tr>
              <tr><td class="severity-low">LOW</td><td>8</td><td>8</td><td>0</td></tr>
            </tbody>
          </table>
          <p>Four Black Team agents conducted parallel offensive assessments across all five PFM implementations. All 28 findings were remediated across 6 debate rounds with full verification. 198 automated tests (143 Python + 55 JS) confirm correctness.</p>

          <h4>Key Findings &amp; Remediations</h4>
          <table class="audit-table">
            <thead><tr><th>Severity</th><th>Finding</th><th>Status</th></tr></thead>
            <tbody>
              <tr><td class="severity-crit">CRIT</td><td>Index offset/length out-of-bounds reads</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-crit">CRIT</td><td>Unbounded meta field injection (DoS)</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-crit">CRIT</td><td>No file size limit on reader (OOM)</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-crit">CRIT</td><td>Path traversal in CLI write commands</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-crit">CRIT</td><td>Missing checksum = pass (fail-open)</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-high">HIGH</td><td>Inline onclick handlers violate CSP nonce</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-high">HIGH</td><td>Timing side-channel in checksum comparison</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-high">HIGH</td><td>Meta key override via duplicate keys</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-high">HIGH</td><td>TOCTOU race in stream recovery</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-high">HIGH</td><td>No format version validation in JS parsers</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-med">MED</td><td>CRLF injection in cross-platform parsing</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-med">MED</td><td>CSV formula injection in converter output</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-med">MED</td><td>YAML frontmatter injection in Markdown export</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-med">MED</td><td>Session storage quota overflow (Chrome ext)</td><td class="status-pass">FIXED</td></tr>
              <tr><td class="severity-med">MED</td><td>Error messages leak internal paths</td><td class="status-pass">FIXED</td></tr>
            </tbody>
          </table>

          <h4>Attack Vectors Tested (No Finding)</h4>
          <table class="audit-table">
            <thead><tr><th>Vector</th><th>Result</th></tr></thead>
            <tbody>
              <tr><td>Malformed PFM magic line injection</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>Section name charset bypass</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>Escape sequence round-trip corruption</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>Encrypted document oracle attack</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>HMAC signature replay / forgery</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>Stream writer crash + corrupt recovery</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>JSON/CSV converter prototype pollution</td><td class="status-pass">DEFENDED</td></tr>
              <tr><td>Cross-implementation checksum mismatch</td><td class="status-pass">DEFENDED</td></tr>
            </tbody>
          </table>

          <div class="cert-box">
            <h3>A+ Certification</h3>
            <p style="margin:0;color:var(--green);">Zero open CRITICAL or HIGH findings. All 28 findings remediated with verification. Defense-in-depth across all five implementations with HMAC-SHA256 signing, AES-256-GCM encryption, constant-time comparisons, and strict input validation at every trust boundary.</p>
          </div>
        </div>
      </div>

      <!-- Hacking Summit Panel -->
      <div class="audit-panel" id="audit-panel-summit">
        <div class="audit-report">
          <h3>Hacking Summit Certification</h3>
          <p style="color:var(--text-muted);">Project: PFM &bull; Date: 2026-02-17 &bull; Debate Rounds: 6 &bull; Final Grade: <span class="grade-badge">A+</span></p>

          <h4>Hardening Timeline</h4>
          <table class="audit-table">
            <thead><tr><th>Round</th><th>Focus</th><th>Findings</th><th>Fixed</th></tr></thead>
            <tbody>
              <tr><td>1&ndash;2</td><td>Core parser security + escape system</td><td>12</td><td>12</td></tr>
              <tr><td>3</td><td>VS Code bugs, dead code, meta limits</td><td>6</td><td>6</td></tr>
              <tr><td>4</td><td>Stream checksum, Chrome offsets, consistency</td><td>8</td><td>8</td></tr>
              <tr><td>5</td><td>Version validation, CLI commands, path hardening</td><td>10</td><td>10</td></tr>
              <tr><td>6</td><td>CSP, timing attacks, CRLF, meta-first-wins</td><td>14</td><td>14</td></tr>
              <tr><td>Scan</td><td>Black Team parallel assessment (4 agents)</td><td>18</td><td>18</td></tr>
            </tbody>
          </table>

          <h4>Security Architecture</h4>
          <ul>
            <li><strong>Integrity:</strong> SHA-256 checksum on all section content, fail-closed verification</li>
            <li><strong>Authentication:</strong> HMAC-SHA256 signing with constant-time comparison</li>
            <li><strong>Encryption:</strong> AES-256-GCM with PBKDF2 key derivation (600K iterations)</li>
            <li><strong>Parsing:</strong> Bounds-checked index reads, CRLF normalization, version gating</li>
            <li><strong>Input validation:</strong> Section name charset enforcement, meta field limits, file size caps</li>
            <li><strong>Cross-impl consistency:</strong> 5 implementations (Python, JS, Chrome, VS Code, SPA) share identical parse/serialize behavior verified by conformance tests</li>
          </ul>

          <h4>Test Coverage</h4>
          <table class="audit-table">
            <thead><tr><th>Suite</th><th>Tests</th><th>Status</th></tr></thead>
            <tbody>
              <tr><td>Python (pytest)</td><td>143</td><td class="status-pass">ALL PASS</td></tr>
              <tr><td>JavaScript (node:test)</td><td>55</td><td class="status-pass">ALL PASS</td></tr>
              <tr><td><strong>Total</strong></td><td><strong>198</strong></td><td class="status-pass"><strong>ALL PASS</strong></td></tr>
            </tbody>
          </table>

          <div class="cert-box">
            <h3>CERTIFIED &mdash; Grade: A+</h3>
            <p style="margin:0;color:var(--green);">6 adversarial debate rounds + full Black Team scan. Zero open vulnerabilities. 198 automated tests. All findings remediated with verification across all five implementations.</p>
            <p style="margin:12px 0 0;font-size:13px;color:var(--text-muted);">Signed: Hacking Summit Certification Board &bull; Date: 2026-02-17</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ========== TOS PAGE ========== -->
<div id="page-tos" class="page-screen">
  <div class="topbar">
    <a class="topbar-brand" href="#" style="text-decoration:none;">PFM</a>
    <span class="topbar-filename">Terms of Service</span>
    <span class="topbar-spacer"></span>
    <button class="topbar-btn" onclick="toggleTheme()">Theme</button>
    <a class="topbar-btn" href="#">Home</a>
  </div>
  <div class="page-body">
    <div class="page-inner">
      <div class="page-hero">
        <h1 class="page-title">Terms of Service</h1>
        <p class="tos-updated">Last updated: February 16, 2026</p>
      </div>

      <div class="tos-content">
        <h3>1. Acceptance of Terms</h3>
        <p>By using PFM (Pure Fucking Magic) software, libraries, tools, web viewer, or file format specification (collectively, the &ldquo;Service&rdquo;), you agree to these Terms of Service. If you do not agree, do not use the Service.</p>

        <h3>2. License</h3>
        <p>PFM is released under the MIT License. You are free to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the conditions of the MIT License.</p>
        <p>The full license text is included with the source code and governs your use of the software.</p>

        <h3>3. The Service</h3>
        <p>PFM provides:</p>
        <ul>
          <li>An open file format specification (<code>.pfm</code>) for AI agent output</li>
          <li>Python and JavaScript libraries for reading, writing, and converting PFM files</li>
          <li>A command-line interface for file operations</li>
          <li>A web-based viewer and converter that runs entirely client-side</li>
        </ul>

        <h3>4. Privacy &amp; Data Handling</h3>
        <p>The PFM web viewer and converter run entirely in your browser. <strong>No files are uploaded to any server.</strong> All processing happens client-side on your machine.</p>
        <ul>
          <li>No analytics or tracking scripts are included</li>
          <li>No cookies are set (except a local theme preference in localStorage)</li>
          <li>No data is transmitted to any third party</li>
          <li>Your files never leave your device</li>
        </ul>

        <h3>5. No Warranty</h3>
        <p>THE SERVICE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.</p>
        <p>PFM&rsquo;s security features (checksums, HMAC signing, AES-256-GCM encryption) are provided as tools. Their correctness depends on proper usage. You are responsible for your own security posture and key management.</p>

        <h3>6. Limitation of Liability</h3>
        <p>IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

        <h3>7. Acceptable Use</h3>
        <p>You may use PFM for any lawful purpose. You agree not to:</p>
        <ul>
          <li>Use PFM to store, transmit, or distribute illegal content</li>
          <li>Attempt to circumvent PFM&rsquo;s security features for malicious purposes</li>
          <li>Misrepresent the provenance or integrity of PFM files</li>
          <li>Use PFM in any way that violates applicable laws or regulations</li>
        </ul>

        <h3>8. Contributions</h3>
        <p>Contributions to PFM are welcome and governed by the project&rsquo;s CONTRIBUTING.md guidelines. By submitting a contribution, you agree to license it under the same MIT License as the project.</p>

        <h3>9. Changes to Terms</h3>
        <p>These terms may be updated from time to time. Changes will be reflected in the &ldquo;Last updated&rdquo; date above. Continued use of the Service after changes constitutes acceptance of the new terms.</p>

        <h3>10. Contact</h3>
        <p>For questions about these terms, open an issue on the project&rsquo;s GitHub repository.</p>
      </div>
    </div>
  </div>
</div>

<script>
/* ================================================================
   PFM Parser â€” Pure client-side .pfm parser
   Mirrors the Python PFMReader logic exactly.
   ================================================================ */
const PFMParser = {
  MAGIC: '#!PFM',
  EOF: '#!END',
  SEC: '#@',
  MAX_SECTIONS: 10000,
  MAX_META_FIELDS: 100,
  MAX_SECTION_NAME_LEN: 64,

  parse(text) {
    const lines = text.split('\n');
    const doc = {
      formatVersion: '1.0',
      isStream: false,
      meta: {},
      sections: [],
      raw: text
    };

    let currentSection = null;
    let sectionLines = [];
    let inMeta = false;
    let inIndex = false;
    let metaFieldCount = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Magic line
      if (line.startsWith(this.MAGIC)) {
        const slash = line.indexOf('/');
        if (slash !== -1) {
          const rest = line.substring(slash + 1);
          const colon = rest.indexOf(':');
          doc.formatVersion = colon !== -1 ? rest.substring(0, colon) : rest;
          doc.isStream = rest.includes(':STREAM');
        }
        if (doc.formatVersion !== '1.0') {
          throw new Error(`Unsupported PFM format version: '${doc.formatVersion}'`);
        }
        continue;
      }

      // EOF
      if (line.startsWith(this.EOF)) {
        flush();
        break;
      }

      // Section header (not escaped)
      if (line.startsWith(this.SEC) && !line.startsWith('\\#')) {
        flush();
        const name = line.substring(this.SEC.length);
        // Validate section name length
        if (name.length > this.MAX_SECTION_NAME_LEN) {
          currentSection = null;
          continue;
        }
        inMeta = (name === 'meta');
        inIndex = (name === 'index' || name === 'index-trailing');
        if (!inMeta && !inIndex) {
          // Enforce section count limit
          if (doc.sections.length >= this.MAX_SECTIONS) {
            currentSection = null;
            continue;
          }
          currentSection = name;
          sectionLines = [];
        } else {
          currentSection = null;
        }
        continue;
      }

      // Meta
      if (inMeta) {
        const sep = line.indexOf(': ');
        if (sep !== -1 && metaFieldCount < this.MAX_META_FIELDS) {
          const key = line.substring(0, sep).trim();
          const val = line.substring(sep + 2).trim();
          // Prevent prototype pollution: reject __proto__, constructor, prototype
          if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            continue;
          }
          // First-wins: prevent duplicate meta key override
          if (!(key in doc.meta)) {
            doc.meta[key] = val;
            metaFieldCount++;
          }
        }
        continue;
      }

      // Index (skip)
      if (inIndex) continue;

      // Content
      if (currentSection !== null) {
        sectionLines.push(this.unescape(line));
      }
    }
    flush();
    return doc;

    function flush() {
      if (currentSection === null) return;
      let content = sectionLines.join('\n');
      if (content.endsWith('\n')) content = content.slice(0, -1);
      doc.sections.push({ name: currentSection, content });
      currentSection = null;
      sectionLines = [];
    }
  },

  unescape(line) {
    if (line.startsWith('\\') && this._hasMarkerAfterBackslashes(line.substring(1))) {
      return line.substring(1);
    }
    return line;
  },

  _hasMarkerAfterBackslashes(line) {
    let i = 0;
    while (i < line.length && line[i] === '\\') i++;
    const rest = line.substring(i);
    return rest.startsWith('#@') || rest.startsWith('#!PFM') || rest.startsWith('#!END');
  },

  async checksum(sections) {
    const encoder = new TextEncoder();
    let allBytes = new Uint8Array(0);
    for (const s of sections) {
      const encoded = encoder.encode(s.content);
      const merged = new Uint8Array(allBytes.length + encoded.length);
      merged.set(allBytes);
      merged.set(encoded, allBytes.length);
      allBytes = merged;
    }
    const hashBuffer = await crypto.subtle.digest('SHA-256', allBytes);
    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
  }
};


/* ================================================================
   Demo File â€” embedded example
   ================================================================ */
const DEMO_PFM = `#!PFM/1.0
#@meta
id: aa2e0354-578f-4740-bb69-82a18443182b
agent: claude-code
model: claude-opus-4-6
created: 2026-02-16T20:02:37.085863+00:00
checksum: 049dcea084f4b095226b78491c11bb10066c7bb7aa6e1f1be777a31beea2f782
tags: example,demo
version: 1.0
#@index
content 329 398
chain 735 330
tools 1073 188
metrics 1271 110
#@content
# Analysis Report

The codebase follows a clean MVC architecture with the following key findings:

1. Authentication is handled via JWT tokens with 24h expiry
2. Database queries use parameterized statements (no SQL injection risk)
3. Rate limiting is configured at 100 req/min per API key
4. CORS is properly restricted to known origins

Recommendation: Add request signing for webhook endpoints.
#@chain
User: Analyze this codebase for security issues and architecture patterns.

Agent: I'll examine the project structure, authentication flow, database layer,
and API configuration.

[Searched: auth/*.py, db/*.py, api/middleware.py]
[Read: 12 files, 3,400 lines]
[Tools: grep for SQL queries, checked CORS headers, traced auth flow]
#@tools
grep(pattern="SELECT|INSERT|UPDATE|DELETE", path="db/")
read_file("api/middleware.py")
read_file("auth/jwt_handler.py")
read_file("config/cors.py")
grep(pattern="rate_limit", path="api/")
#@metrics
tokens_in: 12450
tokens_out: 3200
latency_ms: 8934
model_cost_usd: 0.0847
files_read: 12
lines_analyzed: 3400
#!END`;


/* ================================================================
   Application State
   ================================================================ */
let state = {
  doc: null,
  filename: '',
  activeIndex: -1,
  filteredSections: [],
  wordWrap: true,
  checksumValid: false
};


/* ================================================================
   DOM Refs
   ================================================================ */
const $ = id => document.getElementById(id);
const landing   = $('landing');
const viewer    = $('viewer');
const dropZone  = $('drop-zone');
const fileInput = $('file-input');


/* ================================================================
   File Loading
   ================================================================ */
// Maximum file size for client-side parsing (50 MB)
const MAX_FILE_SIZE = 50 * 1024 * 1024;

function handleFile(file) {
  if (!file) return;
  // Validate file size to prevent browser memory exhaustion
  if (file.size > MAX_FILE_SIZE) {
    alert('File too large. Maximum size is 50 MB.');
    return;
  }
  // Validate file extension
  if (!file.name.toLowerCase().endsWith('.pfm')) {
    alert('Please select a .pfm file.');
    return;
  }
  const reader = new FileReader();
  reader.onerror = function() {
    alert('Error reading file.');
  };
  reader.onload = e => loadPFM(e.target.result, file.name);
  reader.readAsText(file, 'utf-8');
}

function loadPFM(text, filename) {
  const doc = PFMParser.parse(text);
  state.doc = doc;
  state.filename = filename || 'untitled.pfm';
  state.filteredSections = [...doc.sections];
  state.activeIndex = doc.sections.length > 0 ? 0 : -1;

  // Async checksum validation
  PFMSerializer.checksum(doc.sections).then(computed => {
    const expected = doc.meta.checksum || '';
    state.checksumValid = expected !== '' && timingSafeEqual(computed, expected);
    renderChecksumBadge();
  });

  showViewer();
  render();
}

function loadDemo() {
  loadPFM(DEMO_PFM, 'hello.pfm');
}


/* ================================================================
   Screen Switching
   ================================================================ */
function hideAllPages() {
  if ($('page-benchmarks')) $('page-benchmarks').classList.remove('active');
  if ($('page-audits')) $('page-audits').classList.remove('active');
  if ($('page-tos')) $('page-tos').classList.remove('active');
}

function showViewer() {
  landing.classList.add('hidden');
  $('converter').classList.remove('active');
  hideAllPages();
  viewer.classList.add('active');
}

function showLanding() {
  viewer.classList.remove('active');
  $('converter').classList.remove('active');
  hideAllPages();
  landing.classList.remove('hidden');
}

function showPage(page) {
  landing.classList.add('hidden');
  viewer.classList.remove('active');
  $('converter').classList.remove('active');
  hideAllPages();
  const target = $('page-' + page);
  if (target) target.classList.add('active');
  else landing.classList.remove('hidden');
}

function switchAuditTab(tab) {
  document.querySelectorAll('.audit-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.audit-panel').forEach(p => p.classList.remove('active'));
  $('audit-tab-' + tab).classList.add('active');
  $('audit-panel-' + tab).classList.add('active');
}


/* ================================================================
   Rendering
   ================================================================ */
function render() {
  renderFilename();
  renderMeta();
  renderSectionList();
  renderContent();
  renderChecksumBadge();
}

function renderFilename() {
  $('v-filename').textContent = state.filename;
}

function renderChecksumBadge() {
  const badge = $('v-checksum-badge');
  if (state.checksumValid) {
    badge.textContent = 'VALID';
    badge.className = 'badge valid';
  } else {
    badge.textContent = 'INVALID';
    badge.className = 'badge invalid';
  }
}

function renderMeta() {
  const meta = state.doc.meta;
  const keys = Object.keys(meta);
  $('meta-count').textContent = keys.length + ' fields';

  // Build meta display using safe DOM methods instead of innerHTML
  const container = document.createElement('div');
  container.className = 'meta-grid';
  for (const key of keys) {
    // Skip prototype pollution keys
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
    if (!Object.prototype.hasOwnProperty.call(meta, key)) continue;

    const val = meta[key];
    const display = (key === 'checksum' && val.length > 20) ? val.substring(0, 16) + '...' : val;

    const row = document.createElement('div');
    row.className = 'meta-row';

    const keyDiv = document.createElement('div');
    keyDiv.className = 'meta-key';
    keyDiv.textContent = key;

    const valDiv = document.createElement('div');
    valDiv.className = 'meta-val';
    valDiv.textContent = display;
    valDiv.title = val;

    row.appendChild(keyDiv);
    row.appendChild(valDiv);
    container.appendChild(row);
  }
  const metaEl = $('v-meta');
  metaEl.innerHTML = '';
  metaEl.appendChild(container);
}

function renderSectionList() {
  const el = $('v-section-list');
  let html = '';
  for (let i = 0; i < state.filteredSections.length; i++) {
    const s = state.filteredSections[i];
    const bytes = new TextEncoder().encode(s.content).length;
    const sizeStr = bytes >= 1024 ? (bytes / 1024).toFixed(1) + ' KB' : bytes + ' B';
    const cls = i === state.activeIndex ? ' active' : '';
    html += `<div class="section-item${cls}" data-idx="${i}">` +
            `<span class="section-item-name">${esc(s.name)}</span>` +
            `<span class="section-item-size">${sizeStr}</span></div>`;
  }
  el.innerHTML = html;

  // Click handlers
  el.querySelectorAll('.section-item').forEach(item => {
    item.addEventListener('click', () => {
      selectSection(parseInt(item.dataset.idx, 10));
    });
  });
}

function renderContent() {
  const body = $('v-content-body');
  if (state.activeIndex < 0 || state.activeIndex >= state.filteredSections.length) {
    body.innerHTML = '<div class="content-empty">Select a section from the sidebar</div>';
    $('v-content-title').textContent = 'Select a section';
    $('v-content-meta').textContent = '';
    return;
  }

  const s = state.filteredSections[state.activeIndex];
  $('v-content-title').textContent = s.name;

  const bytes = new TextEncoder().encode(s.content).length;
  const lines = s.content.split('\n').length;
  $('v-content-meta').textContent = `${lines} lines \u00b7 ${formatBytes(bytes)}`;

  // Render with line numbers
  const contentLines = s.content.split('\n');
  const nums = contentLines.map((_, i) => i + 1).join('\n');
  const wrapClass = state.wordWrap ? ' wrap' : '';

  body.innerHTML = `<div class="code-container"><pre class="line-numbers">${nums}</pre><pre class="content-pre${wrapClass}">${esc(s.content)}</pre></div>`;
}

function selectSection(idx) {
  if (idx < 0 || idx >= state.filteredSections.length) return;
  state.activeIndex = idx;
  renderSectionList();
  renderContent();
}

function moveSection(delta) {
  const next = state.activeIndex + delta;
  if (next >= 0 && next < state.filteredSections.length) {
    selectSection(next);
    // Scroll active item into view
    const active = document.querySelector('.section-item.active');
    if (active) active.scrollIntoView({ block: 'nearest' });
  }
}


/* ================================================================
   Search / Filter
   ================================================================ */
$('v-search').addEventListener('input', function() {
  const q = this.value.toLowerCase().trim();
  if (!q) {
    state.filteredSections = [...state.doc.sections];
  } else {
    state.filteredSections = state.doc.sections.filter(s =>
      s.name.toLowerCase().includes(q) || s.content.toLowerCase().includes(q)
    );
  }
  state.activeIndex = state.filteredSections.length > 0 ? 0 : -1;
  renderSectionList();
  renderContent();
});


/* ================================================================
   Export
   ================================================================ */
function exportJSON() {
  if (!state.doc) return;
  const data = {
    pfm_version: state.doc.formatVersion,
    meta: state.doc.meta,
    sections: state.doc.sections.map(s => ({ name: s.name, content: s.content }))
  };
  download(JSON.stringify(data, null, 2), state.filename.replace('.pfm', '.json'), 'application/json');
}

function exportMarkdown() {
  if (!state.doc) return;
  let md = '---\n';
  for (const [k, v] of Object.entries(state.doc.meta)) {
    if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
    if (!Object.prototype.hasOwnProperty.call(state.doc.meta, k)) continue;
    // Sanitize key and value to prevent YAML frontmatter injection
    const safeKey = k.replace(/[^a-zA-Z0-9_-]/g, '_');
    const safeVal = String(v).replace(/\n/g, ' ').replace(/^---$/gm, '\\---');
    md += `${safeKey}: ${safeVal}\n`;
  }
  md += '---\n\n';
  for (const s of state.doc.sections) md += `## ${s.name}\n\n${s.content}\n\n`;
  download(md, state.filename.replace('.pfm', '.md'), 'text/markdown');
}

function timingSafeEqual(a, b) {
  var len = Math.max(a.length, b.length);
  var result = a.length === b.length ? 0 : 1;
  for (var i = 0; i < len; i++) result |= (a.charCodeAt(i) || 0) ^ (b.charCodeAt(i) || 0);
  return result === 0;
}

function sanitizeFilename(name) {
  // Strip path separators and dangerous characters
  return name.replace(/[\/\\:*?"<>|]/g, '_').replace(/\.\./g, '_');
}

function download(content, filename, mime) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = sanitizeFilename(filename);
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}


/* ================================================================
   Theme
   ================================================================ */
function toggleTheme() {
  document.body.classList.toggle('light');
  localStorage.setItem('pfm-theme', document.body.classList.contains('light') ? 'light' : 'dark');
}

// Restore theme preference
if (localStorage.getItem('pfm-theme') === 'light') {
  document.body.classList.add('light');
}


/* ================================================================
   Word Wrap
   ================================================================ */
function toggleWrap() {
  state.wordWrap = !state.wordWrap;
  $('btn-wrap').classList.toggle('active', state.wordWrap);
  const pre = document.querySelector('.content-pre');
  if (pre) pre.classList.toggle('wrap', state.wordWrap);
}


/* ================================================================
   Shortcuts Modal
   ================================================================ */
function openShortcuts() {
  $('shortcuts-modal').style.display = 'flex';
}
function closeShortcuts() {
  $('shortcuts-modal').style.display = 'none';
}


/* ================================================================
   Meta Section Toggle
   ================================================================ */
let metaOpen = true;
$('meta-toggle').addEventListener('click', () => {
  metaOpen = !metaOpen;
  $('v-meta').style.display = metaOpen ? '' : 'none';
});


/* ================================================================
   Event Listeners
   ================================================================ */

// Drag & drop
['dragenter', 'dragover'].forEach(evt => {
  dropZone.addEventListener(evt, e => { e.preventDefault(); dropZone.classList.add('dragover'); });
});
['dragleave', 'drop'].forEach(evt => {
  dropZone.addEventListener(evt, e => { e.preventDefault(); dropZone.classList.remove('dragover'); });
});
dropZone.addEventListener('drop', e => {
  const file = e.dataTransfer.files[0];
  if (file) handleFile(file);
});

// Also support drag anywhere on landing (routes to correct handler based on active tab)
landing.addEventListener('dragover', e => {
  e.preventDefault();
  const isConvertTab = $('tab-convert').classList.contains('active');
  (isConvertTab ? convertDropZone : dropZone).classList.add('dragover');
});
landing.addEventListener('dragleave', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  convertDropZone.classList.remove('dragover');
});
landing.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  convertDropZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (!file) return;
  const isConvertTab = $('tab-convert').classList.contains('active');
  if (isConvertTab) {
    handleConvertFile(file);
  } else {
    handleFile(file);
  }
});

// File input
fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

// Demo
$('demo-btn').addEventListener('click', loadDemo);

// Topbar buttons
$('btn-export-json').addEventListener('click', exportJSON);
$('btn-export-md').addEventListener('click', exportMarkdown);
$('btn-theme').addEventListener('click', toggleTheme);
$('btn-wrap').addEventListener('click', toggleWrap);
$('btn-shortcuts').addEventListener('click', openShortcuts);
$('btn-open-new').addEventListener('click', () => {
  // Create a temporary file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.pfm';
  input.onchange = e => handleFile(e.target.files[0]);
  input.click();
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  const target = e.target;
  const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA';

  // Escape always works
  if (e.key === 'Escape') {
    closeShortcuts();
    if (isInput) {
      target.blur();
      if (target.id === 'v-search') {
        target.value = '';
        target.dispatchEvent(new Event('input'));
      }
    }
    return;
  }

  // Don't handle shortcuts when typing in input
  if (isInput) return;

  // Only in viewer mode
  if (!viewer.classList.contains('active')) return;

  switch (e.key) {
    case 'j':
    case 'ArrowDown':
      e.preventDefault();
      moveSection(1);
      break;
    case 'k':
    case 'ArrowUp':
      e.preventDefault();
      moveSection(-1);
      break;
    case '/':
      e.preventDefault();
      $('v-search').focus();
      break;
    case 'w':
      toggleWrap();
      break;
    case 't':
      toggleTheme();
      break;
    case 'o':
      $('btn-open-new').click();
      break;
    case '?':
      openShortcuts();
      break;
  }
});

// Also handle drag onto viewer
viewer.addEventListener('dragover', e => e.preventDefault());
viewer.addEventListener('drop', e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) handleFile(file);
});


/* ================================================================
   Utilities
   ================================================================ */
function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}


/* ================================================================
   Copy Install Command
   ================================================================ */
function copyInstall(el, text) {
  navigator.clipboard.writeText(text).then(() => {
    el.classList.add('copied');
    setTimeout(() => el.classList.remove('copied'), 1500);
  });
}


/* ================================================================
   Tab Switching (Landing)
   ================================================================ */
function switchTab(mode) {
  document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  $('tab-' + mode).classList.add('active');
  $('panel-' + mode).classList.add('active');
}


/* ================================================================
   PFM Serializer â€” builds .pfm file content from structured data
   ================================================================ */
const PFMSerializer = {
  /** Escape a content line that starts with a PFM marker prefix */
  escapeLine(line) {
    if (this._hasMarkerAfterBackslashes(line)) {
      return '\\' + line;
    }
    return line;
  },

  _hasMarkerAfterBackslashes(line) {
    let i = 0;
    while (i < line.length && line[i] === '\\') i++;
    const rest = line.substring(i);
    return rest.startsWith('#@') || rest.startsWith('#!PFM') || rest.startsWith('#!END');
  },

  /** Escape all lines in content */
  escapeContent(content) {
    return content.split('\n').map(line => this.escapeLine(line)).join('\n');
  },

  /** Generate a UUID v4 */
  uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = (Math.random() * 16) | 0;
      return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
  },

  /** Compute SHA-256 checksum of section contents */
  async checksum(sections) {
    const encoder = new TextEncoder();
    let allBytes = new Uint8Array(0);
    for (const s of sections) {
      const encoded = encoder.encode(s.content);
      const merged = new Uint8Array(allBytes.length + encoded.length);
      merged.set(allBytes);
      merged.set(encoded, allBytes.length);
      allBytes = merged;
    }
    const hashBuffer = await crypto.subtle.digest('SHA-256', allBytes);
    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
  },

  /** Serialize sections and meta into a .pfm string */
  async serialize(sections, meta) {
    meta = meta || {};
    // Auto-fill required meta fields
    if (!meta.id) meta.id = this.uuid();
    if (!meta.created) meta.created = new Date().toISOString();
    if (!meta.agent) meta.agent = 'pfm-web-converter';

    // Compute checksum
    const hash = await this.checksum(sections);
    meta.checksum = hash;

    // Build content sections first (to calculate offsets for index)
    const sectionBlocks = [];
    for (const s of sections) {
      const escaped = this.escapeContent(s.content);
      sectionBlocks.push({ name: s.name, escaped, content: s.content });
    }

    // Build the file
    let pfm = '#!PFM/1.0\n';

    // Meta block
    pfm += '#@meta\n';
    for (const [k, v] of Object.entries(meta)) {
      if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
      pfm += k + ': ' + v + '\n';
    }

    // Index block â€” calculate byte offsets
    pfm += '#@index\n';
    // We need to know where sections start, so pre-calculate
    let offset = new TextEncoder().encode(pfm).length;
    // First pass: compute index lines to know their size
    let indexLines = '';
    let tempOffset = 0; // will recalculate after index
    for (const sb of sectionBlocks) {
      indexLines += sb.name + ' 0 0\n'; // placeholder
    }
    offset += new TextEncoder().encode(indexLines).length;

    // Now calculate real offsets
    let indexContent = '';
    for (const sb of sectionBlocks) {
      const header = '#@' + sb.name + '\n';
      const body = sb.escaped + '\n';
      const headerBytes = new TextEncoder().encode(header).length;
      const bodyBytes = new TextEncoder().encode(body).length;
      const sectionSize = headerBytes + bodyBytes;

      indexContent += sb.name + ' ' + offset + ' ' + bodyBytes + '\n';
      offset += sectionSize;
    }

    // Rebuild with real index
    pfm = '#!PFM/1.0\n';
    pfm += '#@meta\n';
    for (const [k, v] of Object.entries(meta)) {
      if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
      pfm += k + ': ' + v + '\n';
    }
    pfm += '#@index\n';
    pfm += indexContent;

    // Section blocks
    for (const sb of sectionBlocks) {
      pfm += '#@' + sb.name + '\n';
      pfm += sb.escaped + '\n';
    }

    pfm += '#!END\n';
    return pfm;
  }
};


/* ================================================================
   Converters â€” transform various formats into PFM sections + meta
   ================================================================ */
const Converters = {
  /** Detect format from filename extension */
  detectFormat(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    if (ext === 'json') return 'json';
    if (ext === 'csv') return 'csv';
    if (ext === 'md' || ext === 'markdown') return 'markdown';
    return 'txt';
  },

  /** Convert JSON to PFM sections + meta */
  fromJSON(text, filename) {
    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      throw new Error('Invalid JSON: ' + e.message);
    }

    if (typeof data !== 'object' || data === null || Array.isArray(data)) {
      throw new Error('JSON must be an object with sections array or key-value pairs');
    }

    const meta = { source_file: filename, source_format: 'json' };
    const sections = [];

    // Format 1: PFM-like structure { meta: {...}, sections: [{name, content}] }
    if (data.sections && Array.isArray(data.sections)) {
      if (data.meta && typeof data.meta === 'object' && !Array.isArray(data.meta)) {
        for (const [k, v] of Object.entries(data.meta)) {
          if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
          if (typeof v === 'string') meta[k] = v;
        }
      }
      for (const s of data.sections) {
        if (!s || typeof s.name !== 'string') continue;
        const content = typeof s.content === 'string' ? s.content : JSON.stringify(s.content, null, 2);
        sections.push({ name: s.name.substring(0, 64), content });
      }
    }
    // Format 2: Flat key-value â€” each key becomes a section
    else {
      for (const [k, v] of Object.entries(data)) {
        if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
        const content = typeof v === 'string' ? v : JSON.stringify(v, null, 2);
        sections.push({ name: k.substring(0, 64), content });
      }
    }

    if (sections.length === 0) {
      sections.push({ name: 'content', content: JSON.stringify(data, null, 2) });
    }

    return { sections, meta };
  },

  /** Convert CSV to PFM sections + meta */
  fromCSV(text, filename) {
    const meta = { source_file: filename, source_format: 'csv' };
    const sections = [];
    const lines = text.split('\n').filter(l => l.trim());

    if (lines.length === 0) {
      throw new Error('CSV file is empty');
    }

    // Try to detect if first row is headers
    const firstRow = this.parseCSVLine(lines[0]);

    // Check for section_name/content format
    const nameIdx = firstRow.findIndex(h => /^(section[_\s]?name|name|section)$/i.test(h.trim()));
    const contentIdx = firstRow.findIndex(h => /^(content|body|text|value)$/i.test(h.trim()));

    if (nameIdx !== -1 && contentIdx !== -1 && lines.length > 1) {
      // Structured CSV with section name + content columns
      for (let i = 1; i < lines.length; i++) {
        const cols = this.parseCSVLine(lines[i]);
        const name = (cols[nameIdx] || '').trim().substring(0, 64);
        const content = (cols[contentIdx] || '').trim();
        if (name) sections.push({ name, content });
      }
    } else {
      // Treat entire CSV as a single data section
      sections.push({ name: 'data', content: text });

      // Also try to provide a structured view
      if (firstRow.length > 1 && lines.length > 1) {
        const headers = firstRow.map(h => h.trim());
        let structured = '';
        for (let i = 1; i < lines.length; i++) {
          const cols = this.parseCSVLine(lines[i]);
          structured += '--- Row ' + i + ' ---\n';
          for (let j = 0; j < headers.length; j++) {
            structured += headers[j] + ': ' + (cols[j] || '').trim() + '\n';
          }
          structured += '\n';
        }
        sections.push({ name: 'structured', content: structured.trim() });
      }
    }

    meta.rows = String(lines.length - 1);
    meta.columns = String(firstRow.length);
    return { sections, meta };
  },

  /** Basic CSV line parser (handles quoted fields) */
  parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (inQuotes) {
        if (ch === '"' && line[i + 1] === '"') {
          current += '"';
          i++;
        } else if (ch === '"') {
          inQuotes = false;
        } else {
          current += ch;
        }
      } else {
        if (ch === '"') {
          inQuotes = true;
        } else if (ch === ',') {
          result.push(current);
          current = '';
        } else {
          current += ch;
        }
      }
    }
    result.push(current);
    return result;
  },

  /** Convert plain text to PFM (single content section) */
  fromTXT(text, filename) {
    const meta = { source_file: filename, source_format: 'text' };
    const sections = [{ name: 'content', content: text.trim() }];
    return { sections, meta };
  },

  /** Convert Markdown to PFM (H2 headings become sections) */
  fromMarkdown(text, filename) {
    const meta = { source_file: filename, source_format: 'markdown' };
    const sections = [];

    // Extract YAML front matter if present
    const fmMatch = text.match(/^---\n([\s\S]*?)\n---\n/);
    let body = text;
    if (fmMatch) {
      body = text.substring(fmMatch[0].length);
      const fmLines = fmMatch[1].split('\n');
      for (const line of fmLines) {
        const sep = line.indexOf(':');
        if (sep !== -1) {
          const key = line.substring(0, sep).trim();
          const val = line.substring(sep + 1).trim();
          if (key && val && key !== '__proto__' && key !== 'constructor' && key !== 'prototype') {
            meta[key] = val;
          }
        }
      }
    }

    // Split by ## headings
    const parts = body.split(/^## /m);

    // Content before first H2
    const preamble = parts[0].trim();
    if (preamble) {
      sections.push({ name: 'content', content: preamble });
    }

    // Each H2 becomes a section
    for (let i = 1; i < parts.length; i++) {
      const lines = parts[i].split('\n');
      const name = lines[0].trim().substring(0, 64);
      const content = lines.slice(1).join('\n').trim();
      if (name) {
        sections.push({ name, content });
      }
    }

    if (sections.length === 0) {
      sections.push({ name: 'content', content: text.trim() });
    }

    return { sections, meta };
  }
};


/* ================================================================
   Converter State & Logic
   ================================================================ */
let convertState = {
  pfmContent: '',
  filename: '',
  sourceFormat: '',
  sections: [],
  meta: {}
};

async function handleConvertFile(file) {
  if (!file) return;
  if (file.size > MAX_FILE_SIZE) {
    alert('File too large. Maximum size is 50 MB.');
    return;
  }

  const format = Converters.detectFormat(file.name);
  const reader = new FileReader();
  reader.onerror = function() { alert('Error reading file.'); };
  reader.onload = async function(e) {
    try {
      const text = e.target.result;
      let result;

      switch (format) {
        case 'json':     result = Converters.fromJSON(text, file.name); break;
        case 'csv':      result = Converters.fromCSV(text, file.name); break;
        case 'markdown': result = Converters.fromMarkdown(text, file.name); break;
        default:         result = Converters.fromTXT(text, file.name); break;
      }

      const pfmContent = await PFMSerializer.serialize(result.sections, result.meta);

      convertState.pfmContent = pfmContent;
      convertState.filename = file.name.replace(/\.[^.]+$/, '.pfm');
      convertState.sourceFormat = format.toUpperCase();
      convertState.sections = result.sections;
      convertState.meta = result.meta;

      showConverter();
    } catch (err) {
      alert('Conversion error: ' + err.message);
    }
  };
  reader.readAsText(file, 'utf-8');
}

function showConverter() {
  landing.classList.add('hidden');
  viewer.classList.remove('active');
  $('converter').classList.add('active');

  $('c-filename').textContent = convertState.filename;
  $('c-source-fmt').textContent = convertState.sourceFormat;
  $('c-sections').textContent = convertState.sections.length;
  $('c-meta').textContent = Object.keys(convertState.meta).length;
  $('c-size').textContent = formatBytes(new TextEncoder().encode(convertState.pfmContent).length);
  $('c-preview').textContent = convertState.pfmContent;
}

function downloadConvertedPFM() {
  download(convertState.pfmContent, convertState.filename, 'text/plain');
}

function viewConvertedInViewer() {
  $('converter').classList.remove('active');
  loadPFM(convertState.pfmContent, convertState.filename);
}

function backFromConverter() {
  $('converter').classList.remove('active');
  showLanding();
}


/* ================================================================
   Additional Export Formats
   ================================================================ */
function escapeCSVFormula(val) {
  if (val && '=+-@\t\r'.indexOf(val[0]) !== -1) return "'" + val;
  return val;
}

function exportCSV() {
  if (!state.doc) return;
  let csv = 'section_name,content\n';
  for (const s of state.doc.sections) {
    var safeName = escapeCSVFormula(s.name).replace(/"/g, '""');
    var safeContent = escapeCSVFormula(s.content).replace(/"/g, '""');
    csv += '"' + safeName + '","' + safeContent + '"\n';
  }
  download(csv, state.filename.replace('.pfm', '.csv'), 'text/csv');
}

function exportTXT() {
  if (!state.doc) return;
  let txt = '';
  for (const s of state.doc.sections) {
    txt += '=== ' + s.name + ' ===\n\n' + s.content + '\n\n';
  }
  download(txt.trim(), state.filename.replace('.pfm', '.txt'), 'text/plain');
}


/* ================================================================
   Converter Event Listeners
   ================================================================ */
// Convert drop zone
const convertDropZone = $('convert-drop-zone');
const convertFileInput = $('convert-file-input');

['dragenter', 'dragover'].forEach(evt => {
  convertDropZone.addEventListener(evt, e => { e.preventDefault(); convertDropZone.classList.add('dragover'); });
});
['dragleave', 'drop'].forEach(evt => {
  convertDropZone.addEventListener(evt, e => { e.preventDefault(); convertDropZone.classList.remove('dragover'); });
});
convertDropZone.addEventListener('drop', e => {
  const file = e.dataTransfer.files[0];
  if (file) handleConvertFile(file);
});
convertFileInput.addEventListener('change', e => handleConvertFile(e.target.files[0]));

// Converter topbar buttons
$('btn-convert-download').addEventListener('click', downloadConvertedPFM);
$('btn-convert-view').addEventListener('click', viewConvertedInViewer);
$('btn-convert-back').addEventListener('click', backFromConverter);

// Additional export buttons in viewer
$('btn-export-csv').addEventListener('click', exportCSV);
$('btn-export-txt').addEventListener('click', exportTXT);


/* ================================================================
   URL Hash â€” load demo if #demo
   ================================================================ */
function handleRoute() {
  const hash = window.location.hash.substring(1);
  if (hash === 'demo') {
    loadDemo();
  } else if (['benchmarks', 'audits', 'tos'].includes(hash)) {
    showPage(hash);
  }
}
window.addEventListener('hashchange', handleRoute);
handleRoute();
</script>
</body>
</html>
